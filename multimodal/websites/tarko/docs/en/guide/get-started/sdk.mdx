---
title: SDK
description: Using Tarko as an SDK in your applications
---

# SDK

Tarko can be used as an SDK to integrate Agent capabilities directly into your applications. This approach gives you full control over the Agent lifecycle and allows for deep customization.

## Installation

Install the core Tarko packages:

```bash
npm install @tarko/agent @tarko/tools
```

For specific tools:

```bash
npm install @tarko/tools-browser @tarko/tools-filesystem
```

## Basic Usage

### Creating an Agent

```typescript
import { Agent } from '@tarko/agent';
import { FileSystemTool, BrowserTool } from '@tarko/tools';

const agent = new Agent({
  name: 'MyAgent',
  description: 'A helpful assistant',
  
  model: {
    provider: 'openai',
    apiKey: process.env.OPENAI_API_KEY,
    model: 'gpt-4'
  },
  
  systemPrompt: `You are a helpful assistant that can:
  - Read and write files
  - Browse the web
  - Execute commands
  
  Always be helpful and accurate.`,
  
  tools: [
    new FileSystemTool(),
    new BrowserTool()
  ]
});
```

### Chat Interface

```typescript
// Simple chat
const response = await agent.chat('Hello, can you help me?');
console.log(response);

// Chat with context
const conversation = agent.createConversation();
const response1 = await conversation.chat('What\'s the weather like?');
const response2 = await conversation.chat('What about tomorrow?');
```

### Streaming Responses

```typescript
const stream = agent.chatStream('Write a long story about AI');

for await (const chunk of stream) {
  if (chunk.type === 'content') {
    process.stdout.write(chunk.data);
  } else if (chunk.type === 'tool_call') {
    console.log('Tool called:', chunk.data.name);
  }
}
```

## Advanced Usage

### Custom Tools

Create domain-specific tools:

```typescript
import { Tool } from '@tarko/agent';

class DatabaseTool implements Tool {
  name = 'query_database';
  description = 'Query the application database';
  
  parameters = {
    type: 'object',
    properties: {
      query: {
        type: 'string',
        description: 'SQL query to execute'
      }
    },
    required: ['query']
  };

  async execute(params: { query: string }) {
    // Your database logic here
    const results = await this.db.query(params.query);
    return { results };
  }

  constructor(private db: DatabaseConnection) {}
}

const agent = new Agent({
  // ... other config
  tools: [
    new DatabaseTool(myDatabase),
    new FileSystemTool()
  ]
});
```

### Event Handling

```typescript
// Listen to Agent events
agent.on('tool_call', (event) => {
  console.log(`Tool called: ${event.data.name}`);
  // Log to analytics, update UI, etc.
});

agent.on('error', (event) => {
  console.error('Agent error:', event.data.error);
  // Handle errors, notify users, etc.
});

agent.on('context_updated', (event) => {
  console.log('Context length:', event.data.newLength);
  // Monitor context usage
});
```

### Context Management

```typescript
const agent = new Agent({
  // ... other config
  context: {
    maxLength: 32000,
    compressionRatio: 0.8,
    retentionStrategy: 'hybrid'
  }
});

// Manual context operations
const summary = await agent.summarizeContext();
const compressed = await agent.compressContext(0.5);
await agent.clearContext();
```

### Agent Hooks

```typescript
const agent = new Agent({
  // ... other config
  hooks: {
    beforeToolCall: async (toolCall) => {
      // Validate tool call
      if (toolCall.name === 'dangerous_operation') {
        throw new Error('Operation not allowed');
      }
    },
    
    afterToolCall: async (result) => {
      // Log result
      await logToolResult(result);
    },
    
    onError: async (error) => {
      // Custom error handling
      await notifyAdmins(error);
    }
  }
});
```

## Integration Patterns

### Express.js Integration

```typescript
import express from 'express';
import { Agent } from '@tarko/agent';

const app = express();
const agent = new Agent(config);

app.use(express.json());

// Chat endpoint
app.post('/chat', async (req, res) => {
  try {
    const { message, conversationId } = req.body;
    
    const conversation = conversationId 
      ? agent.getConversation(conversationId)
      : agent.createConversation();
    
    const response = await conversation.chat(message);
    
    res.json({
      response,
      conversationId: conversation.id
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Streaming endpoint
app.get('/chat/stream', async (req, res) => {
  const { message } = req.query;
  
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });
  
  const stream = agent.chatStream(message as string);
  
  for await (const chunk of stream) {
    res.write(`data: ${JSON.stringify(chunk)}\n\n`);
  }
  
  res.end();
});

app.listen(3000);
```

### React Integration

```typescript
import { useState, useEffect } from 'react';
import { Agent } from '@tarko/agent';

function useAgent(config: AgentConfig) {
  const [agent, setAgent] = useState<Agent | null>(null);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    const agentInstance = new Agent(config);
    setAgent(agentInstance);
    
    return () => {
      agentInstance.dispose();
    };
  }, []);
  
  const chat = async (message: string) => {
    if (!agent) return;
    
    setLoading(true);
    try {
      const response = await agent.chat(message);
      return response;
    } finally {
      setLoading(false);
    }
  };
  
  return { agent, chat, loading };
}

function ChatComponent() {
  const { chat, loading } = useAgent({
    model: { provider: 'openai', apiKey: 'your-key', model: 'gpt-4' },
    tools: []
  });
  
  const [message, setMessage] = useState('');
  const [response, setResponse] = useState('');
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const result = await chat(message);
    setResponse(result || '');
    setMessage('');
  };
  
  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          disabled={loading}
        />
        <button type="submit" disabled={loading}>
          {loading ? 'Thinking...' : 'Send'}
        </button>
      </form>
      {response && <div>{response}</div>}
    </div>
  );
}
```

### Background Processing

```typescript
import { Worker } from 'worker_threads';
import { Agent } from '@tarko/agent';

// worker.js
const agent = new Agent({
  model: { provider: 'openai', apiKey: process.env.OPENAI_API_KEY },
  tools: [new FileSystemTool()]
});

process.on('message', async (task) => {
  try {
    const result = await agent.chat(task.message);
    process.send({ id: task.id, result });
  } catch (error) {
    process.send({ id: task.id, error: error.message });
  }
});

// main.js
class AgentWorkerPool {
  private workers: Worker[] = [];
  private taskQueue: any[] = [];
  
  constructor(private poolSize: number = 4) {
    for (let i = 0; i < poolSize; i++) {
      this.createWorker();
    }
  }
  
  private createWorker() {
    const worker = new Worker('./worker.js');
    worker.on('message', this.handleWorkerMessage.bind(this));
    this.workers.push(worker);
  }
  
  async processTask(message: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const task = {
        id: Math.random().toString(36),
        message,
        resolve,
        reject
      };
      
      this.taskQueue.push(task);
      this.processQueue();
    });
  }
  
  private processQueue() {
    // Worker assignment logic
  }
  
  private handleWorkerMessage(data: any) {
    // Handle worker responses
  }
}
```

## Best Practices

### Error Handling

```typescript
try {
  const response = await agent.chat(message);
  return response;
} catch (error) {
  if (error instanceof ToolExecutionError) {
    // Handle tool-specific errors
    console.error('Tool error:', error.toolName, error.message);
  } else if (error instanceof ModelProviderError) {
    // Handle model provider errors
    console.error('Model error:', error.provider, error.message);
  } else {
    // Handle general errors
    console.error('Unexpected error:', error.message);
  }
  
  throw error;
}
```

### Resource Management

```typescript
class AgentManager {
  private agents = new Map<string, Agent>();
  
  getAgent(userId: string): Agent {
    if (!this.agents.has(userId)) {
      const agent = new Agent(this.getConfigForUser(userId));
      this.agents.set(userId, agent);
      
      // Cleanup after inactivity
      setTimeout(() => {
        this.agents.delete(userId);
        agent.dispose();
      }, 30 * 60 * 1000); // 30 minutes
    }
    
    return this.agents.get(userId)!;
  }
  
  dispose() {
    for (const agent of this.agents.values()) {
      agent.dispose();
    }
    this.agents.clear();
  }
}
```

### Performance Optimization

```typescript
// Use connection pooling for database tools
const agent = new Agent({
  tools: [
    new DatabaseTool({
      pool: {
        min: 2,
        max: 10,
        acquireTimeoutMillis: 30000
      }
    })
  ]
});

// Implement caching for expensive operations
const cache = new Map();

class CachedSearchTool extends SearchTool {
  async execute(params: { query: string }) {
    const cacheKey = `search:${params.query}`;
    
    if (cache.has(cacheKey)) {
      return cache.get(cacheKey);
    }
    
    const result = await super.execute(params);
    cache.set(cacheKey, result);
    
    return result;
  }
}
```
