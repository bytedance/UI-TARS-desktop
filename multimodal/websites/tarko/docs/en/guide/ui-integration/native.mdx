---
title: Native UI Integration
description: Integrate Tarko agents with native desktop and mobile applications
---

# Native UI Integration

Learn how to integrate **Tarko Agents** with native desktop and mobile applications.

## Desktop Applications

### Electron Integration

Build desktop apps with Electron and **Tarko**:

#### 1. Setup Electron Project

```bash
npm install electron @tarko/agent-client
npm install --save-dev electron-builder
```

#### 2. Main Process Integration

```typescript
// main.ts
import { app, BrowserWindow, ipcMain } from 'electron';
import { AgentClient } from '@tarko/agent-client';
import path from 'path';

let mainWindow: BrowserWindow;
let agentClient: AgentClient;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  mainWindow.loadFile('index.html');
}

function initializeAgent() {
  agentClient = new AgentClient({
    endpoint: 'http://localhost:3000',
  });
}

// IPC handlers for agent communication
ipcMain.handle('agent:sendMessage', async (event, message: string) => {
  try {
    const response = await agentClient.sendMessage(message);
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('agent:getHistory', async (event, sessionId: string) => {
  try {
    const history = await agentClient.getSessionHistory(sessionId);
    return { success: true, data: history };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

app.whenReady().then(() => {
  initializeAgent();
  createWindow();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});
```

#### 3. Preload Script

```typescript
// preload.ts
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('agentAPI', {
  sendMessage: (message: string) => 
    ipcRenderer.invoke('agent:sendMessage', message),
  
  getHistory: (sessionId: string) => 
    ipcRenderer.invoke('agent:getHistory', sessionId),
  
  onAgentEvent: (callback: (event: any) => void) => {
    ipcRenderer.on('agent:event', (event, data) => callback(data));
  },
});

// Type definitions for TypeScript
declare global {
  interface Window {
    agentAPI: {
      sendMessage: (message: string) => Promise<any>;
      getHistory: (sessionId: string) => Promise<any>;
      onAgentEvent: (callback: (event: any) => void) => void;
    };
  }
}
```

#### 4. Renderer Process

```typescript
// renderer.ts
class ElectronAgentUI {
  private messages: any[] = [];
  private sessionId: string;

  constructor() {
    this.sessionId = this.generateSessionId();
    this.setupEventListeners();
    this.loadHistory();
  }

  private setupEventListeners() {
    // Listen for agent events
    window.agentAPI.onAgentEvent((event) => {
      this.handleAgentEvent(event);
    });

    // Setup UI event listeners
    const sendButton = document.getElementById('send-button');
    const messageInput = document.getElementById('message-input') as HTMLInputElement;

    sendButton?.addEventListener('click', () => {
      this.sendMessage(messageInput.value);
    });

    messageInput?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        this.sendMessage(messageInput.value);
      }
    });
  }

  private async sendMessage(message: string) {
    if (!message.trim()) return;

    // Add user message to UI
    this.addMessage({ role: 'user', content: message });
    
    // Clear input
    const messageInput = document.getElementById('message-input') as HTMLInputElement;
    messageInput.value = '';

    try {
      const response = await window.agentAPI.sendMessage(message);
      if (response.success) {
        this.addMessage({ role: 'assistant', content: response.data.content });
      } else {
        this.showError(response.error);
      }
    } catch (error) {
      this.showError('Failed to send message');
    }
  }

  private async loadHistory() {
    try {
      const response = await window.agentAPI.getHistory(this.sessionId);
      if (response.success) {
        this.messages = response.data;
        this.renderMessages();
      }
    } catch (error) {
      console.error('Failed to load history:', error);
    }
  }

  private addMessage(message: any) {
    this.messages.push(message);
    this.renderMessages();
  }

  private renderMessages() {
    const messagesContainer = document.getElementById('messages');
    if (!messagesContainer) return;

    messagesContainer.innerHTML = '';
    
    this.messages.forEach(message => {
      const messageElement = document.createElement('div');
      messageElement.className = `message ${message.role}`;
      messageElement.textContent = message.content;
      messagesContainer.appendChild(messageElement);
    });

    // Scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  private handleAgentEvent(event: any) {
    switch (event.type) {
      case 'tool_call':
        this.showToolCall(event.data);
        break;
      case 'tool_result':
        this.showToolResult(event.data);
        break;
      case 'thinking':
        this.showThinking(event.data);
        break;
    }
  }

  private showToolCall(data: any) {
    // Show tool execution in UI
    console.log('Tool call:', data);
  }

  private showToolResult(data: any) {
    // Show tool result in UI
    console.log('Tool result:', data);
  }

  private showThinking(data: any) {
    // Show agent thinking process
    console.log('Agent thinking:', data);
  }

  private showError(error: string) {
    // Show error message in UI
    console.error('Error:', error);
  }

  private generateSessionId(): string {
    return 'session-' + Math.random().toString(36).substr(2, 9);
  }
}

// Initialize the app
const app = new ElectronAgentUI();
```

### Tauri Integration

Build lightweight desktop apps with Tauri:

#### 1. Setup Tauri Project

```bash
npm create tauri-app my-agent-app
cd my-agent-app
npm install @tarko/agent-client
```

#### 2. Tauri Commands

```rust
// src-tauri/src/main.rs
use tauri::command;
use reqwest;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct AgentResponse {
    content: String,
    success: bool,
}

#[command]
async fn send_message_to_agent(message: String) -> Result<AgentResponse, String> {
    let client = reqwest::Client::new();
    let response = client
        .post("http://localhost:3000/api/chat")
        .json(&serde_json::json!({
            "message": message
        }))
        .send()
        .await
        .map_err(|e| e.to_string())?;

    let agent_response: AgentResponse = response
        .json()
        .await
        .map_err(|e| e.to_string())?;

    Ok(agent_response)
}

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![send_message_to_agent])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

#### 3. Frontend Integration

```typescript
// src/agent.ts
import { invoke } from '@tauri-apps/api/tauri';

class TauriAgentClient {
  async sendMessage(message: string): Promise<any> {
    try {
      const response = await invoke('send_message_to_agent', { message });
      return response;
    } catch (error) {
      throw new Error(`Failed to send message: ${error}`);
    }
  }
}

export const agentClient = new TauriAgentClient();
```

## Mobile Applications

### React Native Integration

#### 1. Setup React Native Project

```bash
npx react-native init MyAgentApp
cd MyAgentApp
npm install axios react-native-webrtc
```

#### 2. Agent Client

```typescript
// src/services/AgentClient.ts
import axios from 'axios';

class MobileAgentClient {
  private baseURL: string;
  private sessionId: string;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
    this.sessionId = this.generateSessionId();
  }

  async sendMessage(message: string): Promise<any> {
    try {
      const response = await axios.post(`${this.baseURL}/api/chat`, {
        message,
        sessionId: this.sessionId,
      });
      return response.data;
    } catch (error) {
      throw new Error(`Failed to send message: ${error}`);
    }
  }

  async getHistory(): Promise<any[]> {
    try {
      const response = await axios.get(
        `${this.baseURL}/api/sessions/${this.sessionId}/messages`
      );
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get history: ${error}`);
    }
  }

  private generateSessionId(): string {
    return 'mobile-session-' + Math.random().toString(36).substr(2, 9);
  }
}

export default MobileAgentClient;
```

#### 3. Chat Component

```typescript
// src/components/ChatScreen.tsx
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  StyleSheet,
} from 'react-native';
import MobileAgentClient from '../services/AgentClient';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

const ChatScreen: React.FC = () => {
  const [client] = useState(() => new MobileAgentClient('http://localhost:3000'));
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputText, setInputText] = useState('');
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    loadHistory();
  }, []);

  const loadHistory = async () => {
    try {
      const history = await client.getHistory();
      setMessages(history);
    } catch (error) {
      console.error('Failed to load history:', error);
    }
  };

  const sendMessage = async () => {
    if (!inputText.trim() || loading) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: inputText,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInputText('');
    setLoading(true);

    try {
      const response = await client.sendMessage(inputText);
      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: response.content,
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Failed to send message:', error);
    } finally {
      setLoading(false);
    }
  };

  const renderMessage = ({ item }: { item: Message }) => (
    <View style={[styles.message, styles[item.role]]}>
      <Text style={[styles.messageText, styles[`${item.role}Text`]]}>
        {item.content}
      </Text>
    </View>
  );

  return (
    <View style={styles.container}>
      <FlatList
        data={messages}
        renderItem={renderMessage}
        keyExtractor={item => item.id}
        style={styles.messagesList}
      />
      <View style={styles.inputContainer}>
        <TextInput
          style={styles.textInput}
          value={inputText}
          onChangeText={setInputText}
          placeholder="Type your message..."
          multiline
          editable={!loading}
        />
        <TouchableOpacity
          style={[styles.sendButton, loading && styles.disabledButton]}
          onPress={sendMessage}
          disabled={loading}
        >
          <Text style={styles.sendButtonText}>
            {loading ? '...' : 'Send'}
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  messagesList: {
    flex: 1,
    padding: 16,
  },
  message: {
    marginBottom: 12,
    padding: 12,
    borderRadius: 8,
    maxWidth: '80%',
  },
  user: {
    backgroundColor: '#007bff',
    alignSelf: 'flex-end',
  },
  assistant: {
    backgroundColor: '#f8f9fa',
    alignSelf: 'flex-start',
  },
  messageText: {
    fontSize: 16,
  },
  userText: {
    color: '#fff',
  },
  assistantText: {
    color: '#333',
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#e9ecef',
  },
  textInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    marginRight: 8,
    maxHeight: 100,
  },
  sendButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    justifyContent: 'center',
  },
  disabledButton: {
    opacity: 0.5,
  },
  sendButtonText: {
    color: '#fff',
    fontWeight: 'bold',
  },
});

export default ChatScreen;
```

### Flutter Integration

#### 1. Setup Flutter Project

```yaml
# pubspec.yaml
dependencies:
  flutter:
    sdk: flutter
  http: ^0.13.5
  web_socket_channel: ^2.4.0
```

#### 2. Agent Service

```dart
// lib/services/agent_service.dart
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:web_socket_channel/web_socket_channel.dart';

class AgentService {
  final String baseUrl;
  final String sessionId;
  WebSocketChannel? _channel;

  AgentService({required this.baseUrl}) 
      : sessionId = 'flutter-session-${DateTime.now().millisecondsSinceEpoch}';

  Future<Map<String, dynamic>> sendMessage(String message) async {
    try {
      final response = await http.post(
        Uri.parse('$baseUrl/api/chat'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'message': message,
          'sessionId': sessionId,
        }),
      );

      if (response.statusCode == 200) {
        return jsonDecode(response.body);
      } else {
        throw Exception('Failed to send message: ${response.statusCode}');
      }
    } catch (e) {
      throw Exception('Failed to send message: $e');
    }
  }

  Future<List<dynamic>> getHistory() async {
    try {
      final response = await http.get(
        Uri.parse('$baseUrl/api/sessions/$sessionId/messages'),
      );

      if (response.statusCode == 200) {
        return jsonDecode(response.body);
      } else {
        throw Exception('Failed to get history: ${response.statusCode}');
      }
    } catch (e) {
      throw Exception('Failed to get history: $e');
    }
  }

  void connectWebSocket(Function(dynamic) onMessage) {
    final wsUrl = baseUrl.replaceFirst('http', 'ws');
    _channel = WebSocketChannel.connect(Uri.parse('$wsUrl/ws'));
    
    _channel!.stream.listen(
      (data) {
        final decoded = jsonDecode(data);
        onMessage(decoded);
      },
      onError: (error) {
        print('WebSocket error: $error');
      },
    );
  }

  void disconnectWebSocket() {
    _channel?.sink.close();
  }
}
```

#### 3. Chat Widget

```dart
// lib/widgets/chat_widget.dart
import 'package:flutter/material.dart';
import '../services/agent_service.dart';

class ChatWidget extends StatefulWidget {
  @override
  _ChatWidgetState createState() => _ChatWidgetState();
}

class _ChatWidgetState extends State<ChatWidget> {
  final AgentService _agentService = AgentService(baseUrl: 'http://localhost:3000');
  final TextEditingController _controller = TextEditingController();
  final List<ChatMessage> _messages = [];
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _loadHistory();
    _agentService.connectWebSocket(_handleWebSocketMessage);
  }

  @override
  void dispose() {
    _agentService.disconnectWebSocket();
    _controller.dispose();
    super.dispose();
  }

  void _loadHistory() async {
    try {
      final history = await _agentService.getHistory();
      setState(() {
        _messages.clear();
        _messages.addAll(history.map((msg) => ChatMessage.fromJson(msg)));
      });
    } catch (e) {
      print('Failed to load history: $e');
    }
  }

  void _handleWebSocketMessage(dynamic data) {
    // Handle real-time events
    print('WebSocket message: $data');
  }

  void _sendMessage() async {
    final text = _controller.text.trim();
    if (text.isEmpty || _isLoading) return;

    setState(() {
      _messages.add(ChatMessage(
        role: 'user',
        content: text,
        timestamp: DateTime.now(),
      ));
      _isLoading = true;
    });

    _controller.clear();

    try {
      final response = await _agentService.sendMessage(text);
      setState(() {
        _messages.add(ChatMessage(
          role: 'assistant',
          content: response['content'],
          timestamp: DateTime.now(),
        ));
      });
    } catch (e) {
      print('Failed to send message: $e');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Agent Chat'),
      ),
      body: Column(
        children: [
          Expanded(
            child: ListView.builder(
              itemCount: _messages.length,
              itemBuilder: (context, index) {
                final message = _messages[index];
                return _buildMessageBubble(message);
              },
            ),
          ),
          _buildInputArea(),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(ChatMessage message) {
    final isUser = message.role == 'user';
    return Align(
      alignment: isUser ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: EdgeInsets.symmetric(horizontal: 16, vertical: 4),
        padding: EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: isUser ? Colors.blue : Colors.grey[200],
          borderRadius: BorderRadius.circular(8),
        ),
        child: Text(
          message.content,
          style: TextStyle(
            color: isUser ? Colors.white : Colors.black,
          ),
        ),
      ),
    );
  }

  Widget _buildInputArea() {
    return Container(
      padding: EdgeInsets.all(16),
      decoration: BoxDecoration(
        border: Border(top: BorderSide(color: Colors.grey[300]!)),
      ),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _controller,
              decoration: InputDecoration(
                hintText: 'Type your message...',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              enabled: !_isLoading,
              onSubmitted: (_) => _sendMessage(),
            ),
          ),
          SizedBox(width: 8),
          ElevatedButton(
            onPressed: _isLoading ? null : _sendMessage,
            child: _isLoading 
                ? SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : Text('Send'),
          ),
        ],
      ),
    );
  }
}

class ChatMessage {
  final String role;
  final String content;
  final DateTime timestamp;

  ChatMessage({
    required this.role,
    required this.content,
    required this.timestamp,
  });

  factory ChatMessage.fromJson(Map<String, dynamic> json) {
    return ChatMessage(
      role: json['role'],
      content: json['content'],
      timestamp: DateTime.parse(json['timestamp']),
    );
  }
}
```

## Best Practices

### Security

1. **API Key Management**: Store API keys securely
2. **HTTPS**: Always use HTTPS in production
3. **Input Validation**: Validate all user inputs
4. **Rate Limiting**: Implement rate limiting for API calls

### Performance

1. **Connection Pooling**: Reuse HTTP connections
2. **Caching**: Cache responses when appropriate
3. **Offline Support**: Handle network failures gracefully
4. **Background Processing**: Use background threads for API calls

### User Experience

1. **Loading States**: Show loading indicators
2. **Error Handling**: Provide clear error messages
3. **Retry Logic**: Implement automatic retry for failed requests
4. **Offline Mode**: Support offline functionality when possible

## Next Steps

- [Agent Protocol →](/guide/advanced/agent-protocol)
- [Event Stream →](/guide/basic/event-stream)
- [Configuration →](/guide/basic/configuration)
