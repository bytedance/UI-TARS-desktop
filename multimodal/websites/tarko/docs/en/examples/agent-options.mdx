---
title: Agent Options Examples
description: Learn how to implement configurable agent behavior with Agent Options
---

# Agent Options Examples

Agent Options allow you to create configurable, session-specific settings that users can toggle directly from the chat interface. This enables dynamic agent behavior customization without requiring code changes or server restarts.

## Overview

This guide provides practical examples of implementing Agent Options in your Tarko applications:

- **Basic Example**: Simple chatbot with fundamental options
- **Advanced Example**: Complex multi-modal assistant with extensive customization

## Basic Example

A simple chatbot with fundamental agent options:

```typescript
import { Agent, createTool } from '@tarko/agent';
import { AgentServerOptions } from '@tarko/interface';

// 1. Define Agent Options Schema
const serverOptions: AgentServerOptions = {
  port: 3000,
  agentOptions: {
    type: 'object',
    properties: {
      // Boolean option - Toggle switch
      verboseMode: {
        type: 'boolean',
        title: 'Verbose Mode',
        description: 'Provide detailed explanations in responses',
        default: false,
      },

      // Binary enum - Toggle buttons
      responseStyle: {
        type: 'string',
        title: 'Response Style',
        description: 'Choose how the agent responds',
        enum: ['casual', 'formal'],
        default: 'casual',
      },

      // Multi enum - Dropdown
      language: {
        type: 'string',
        title: 'Response Language',
        description: 'Language for agent responses',
        enum: ['english', 'chinese', 'japanese'],
        default: 'english',
      },
    },
  },
};

// 2. Create Agent with Options Support
class BasicChatAgent extends Agent {
  constructor() {
    super({
      name: 'BasicChatAgent',
      instructions: 'You are a helpful assistant that adapts to user preferences.',
      model: {
        apiKey: process.env.OPENAI_API_KEY,
        baseURL: 'https://api.openai.com/v1',
        model: 'gpt-4'
      }
    });
  }

  async run(input: string, runOptions?: { sessionId?: string }) {
    // Get current options from session metadata
    const sessionMetadata = this.getEventStream().getSessionMetadata(runOptions?.sessionId);
    const options = sessionMetadata?.agentOptions || {};

    const isVerbose = options.verboseMode || false;
    const style = options.responseStyle || 'casual';
    const language = options.language || 'english';

    // Customize instructions based on options
    let customInstructions = this.instructions;

    // Add verbose instruction if enabled
    if (isVerbose) {
      customInstructions += this.getVerboseInstruction(language);
    }

    // Add style instruction
    customInstructions += this.getStyleInstruction(style, language);

    // Add language instruction
    customInstructions += this.getLanguageInstruction(language);

    // Temporarily update instructions for this run
    const originalInstructions = this.instructions;
    this.instructions = customInstructions;

    try {
      const result = await super.run(input);
      return result;
    } finally {
      // Restore original instructions
      this.instructions = originalInstructions;
    }
  }

  private getVerboseInstruction(language: string): string {
    const instructions = {
      english: '\n\nAlways provide detailed explanations and show your reasoning process step by step.',
      chinese: '\n\n始终提供详细的解释并逐步展示您的推理过程。',
      japanese: '\n\n常に詳細な説明を提供し、推論プロセスを段階的に示してください。',
    };
    return instructions[language] || instructions.english;
  }

  private getStyleInstruction(style: string, language: string): string {
    const styles = {
      english: {
        casual: '\n\nUse a casual, friendly tone in your responses.',
        formal: '\n\nMaintain a formal, professional tone in your responses.',
      },
      chinese: {
        casual: '\n\n在回复中使用随意、友好的语调。',
        formal: '\n\n在回复中保持正式、专业的语调。',
      },
      japanese: {
        casual: '\n\n回答ではカジュアルでフレンドリーなトーンを使用してください。',
        formal: '\n\n回答では正式で専門的なトーンを維持してください。',
      },
    };
    return styles[language]?.[style] || styles.english.casual;
  }

  private getLanguageInstruction(language: string): string {
    const instructions = {
      english: '\n\nRespond in English.',
      chinese: '\n\n用中文回复。',
      japanese: '\n\n日本語で回答してください。',
    };
    return instructions[language] || instructions.english;
  }
}

export { serverOptions, BasicChatAgent };
```

## Advanced Example

A comprehensive multi-modal AI assistant with extensive customization:

```typescript
import { Agent, createTool } from '@tarko/agent';
import { AgentServerOptions } from '@tarko/interface';

// Advanced Agent Options Configuration
const advancedServerOptions: AgentServerOptions = {
  port: 3000,
  agentOptions: {
    type: 'object',
    properties: {
      // === UI Behavior Options ===
      showThinkingProcess: {
        type: 'boolean',
        title: 'Show Thinking Process',
        description: 'Display step-by-step reasoning in responses',
        default: true,
      },

      showProgressIndicators: {
        type: 'boolean',
        title: 'Show Progress',
        description: 'Display progress indicators for long operations',
        default: true,
      },

      // === Agent Personality ===
      personalityMode: {
        type: 'string',
        title: 'Personality',
        description: 'How the agent communicates and behaves',
        enum: ['professional', 'friendly', 'technical', 'creative'],
        default: 'friendly',
      },

      communicationStyle: {
        type: 'string',
        title: 'Communication Style',
        description: 'Tone and approach for responses',
        enum: ['concise', 'detailed', 'explanatory'],
        default: 'detailed',
      },

      // === Tool and Feature Controls ===
      enableWebSearch: {
        type: 'boolean',
        title: 'Web Search',
        description: 'Allow agent to search the internet for current information',
        default: false,
      },

      enableCodeGeneration: {
        type: 'boolean',
        title: 'Code Generation',
        description: 'Enable automatic code generation and execution',
        default: true,
      },

      enableImageAnalysis: {
        type: 'boolean',
        title: 'Image Analysis',
        description: 'Analyze and describe uploaded images',
        default: true,
      },

      // === Output Format Options ===
      preferredCodeLanguage: {
        type: 'string',
        title: 'Code Language',
        description: 'Default programming language for code examples',
        enum: ['typescript', 'javascript', 'python', 'go', 'rust'],
        default: 'typescript',
      },

      outputFormat: {
        type: 'string',
        title: 'Output Format',
        description: 'How to structure responses',
        enum: ['markdown', 'html', 'plain'],
        default: 'markdown',
      },

      includeSourceReferences: {
        type: 'boolean',
        title: 'Source References',
        description: 'Include citations and references in responses',
        default: true,
      },

      // === Performance and Limits ===
      maxReasoningSteps: {
        type: 'string',
        title: 'Max Reasoning Steps',
        description: 'Maximum number of reasoning steps for complex problems',
        enum: ['5', '10', '20', 'unlimited'],
        default: '10',
      },

      responseTimePreference: {
        type: 'string',
        title: 'Response Speed',
        description: 'Balance between response speed and quality',
        enum: ['fast', 'balanced', 'thorough'],
        default: 'balanced',
      },

      // === Content Filtering ===
      contentSafetyLevel: {
        type: 'string',
        title: 'Content Safety',
        description: 'Level of content filtering and safety checks',
        enum: ['strict', 'moderate', 'permissive'],
        default: 'moderate',
      },

      // === Experimental Features ===
      enableExperimentalFeatures: {
        type: 'boolean',
        title: 'Experimental Features',
        description: 'Enable bleeding-edge features (may be unstable)',
        default: false,
      },
    },
  },
};

// Advanced Agent Implementation
class AdvancedMultiModalAgent extends Agent {
  constructor() {
    super({
      name: 'AdvancedMultiModalAgent',
      instructions: 'You are an advanced AI assistant with extensive customization options.',
      tools: [
        createTool({
          name: 'web_search',
          description: 'Search the web for current information',
          parameters: {
            type: 'object',
            properties: {
              query: { type: 'string', description: 'Search query' }
            },
            required: ['query']
          },
          handler: async ({ query }) => {
            // Web search implementation
            return `Search results for: ${query}`;
          }
        }),
        createTool({
          name: 'generate_code',
          description: 'Generate code in specified language',
          parameters: {
            type: 'object',
            properties: {
              description: { type: 'string', description: 'What the code should do' },
              language: { type: 'string', description: 'Programming language' }
            },
            required: ['description', 'language']
          },
          handler: async ({ description, language }) => {
            // Code generation implementation
            return `// ${language} code for: ${description}\nconsole.log('Generated code');`;
          }
        })
      ],
      model: {
        apiKey: process.env.OPENAI_API_KEY,
        baseURL: 'https://api.openai.com/v1',
        model: 'gpt-4'
      }
    });
  }

  async run(input: string, runOptions?: { sessionId?: string }) {
    // Get current options from session metadata
    const sessionMetadata = this.getEventStream().getSessionMetadata(runOptions?.sessionId);
    const options = sessionMetadata?.agentOptions || {};

    // Build custom instructions based on options
    let customInstructions = this.buildCustomInstructions(options);

    // Temporarily update instructions for this run
    const originalInstructions = this.instructions;
    this.instructions = customInstructions;

    try {
      const result = await super.run(input);
      return result;
    } finally {
      // Restore original instructions
      this.instructions = originalInstructions;
    }
  }

  private buildCustomInstructions(options: any): string {
    let instructions = this.instructions;

    // Apply personality and communication style
    const personality = options.personalityMode || 'friendly';
    const style = options.communicationStyle || 'detailed';
    instructions += this.getPersonalityInstructions(personality, style);

    // Thinking process
    if (options.showThinkingProcess) {
      instructions += '\n\nAlways explain your reasoning process step by step.';
    }

    // Progress indicators
    if (options.showProgressIndicators) {
      instructions += '\n\nWhen performing long operations, provide progress updates.';
    }

    // Tool preferences
    if (!options.enableWebSearch) {
      instructions += '\n\nDo not use web search tools unless absolutely necessary.';
    }

    if (!options.enableCodeGeneration) {
      instructions += '\n\nAvoid generating code unless specifically requested.';
    }

    if (!options.enableImageAnalysis) {
      instructions += '\n\nDo not analyze images unless specifically requested.';
    }

    // Code language preference
    if (options.preferredCodeLanguage) {
      instructions += `\n\nWhen generating code, prefer ${options.preferredCodeLanguage} unless another language is specified.`;
    }

    // Output format
    const format = options.outputFormat || 'markdown';
    if (format === 'html') {
      instructions += '\n\nFormat responses using HTML tags instead of markdown.';
    } else if (format === 'plain') {
      instructions += '\n\nUse plain text formatting without markdown or HTML.';
    }

    // Source references
    if (options.includeSourceReferences) {
      instructions += '\n\nAlways include source references and citations when applicable.';
    }

    // Reasoning steps limit
    const maxSteps = options.maxReasoningSteps;
    if (maxSteps && maxSteps !== 'unlimited') {
      instructions += `\n\nLimit reasoning to a maximum of ${maxSteps} steps.`;
    }

    // Response time preference
    const timePreference = options.responseTimePreference || 'balanced';
    if (timePreference === 'fast') {
      instructions += '\n\nPrioritize quick responses over thoroughness.';
    } else if (timePreference === 'thorough') {
      instructions += '\n\nPrioritize thoroughness and accuracy over response speed.';
    }

    // Content safety
    const safetyLevel = options.contentSafetyLevel || 'moderate';
    if (safetyLevel === 'strict') {
      instructions += '\n\nApply strict content filtering and avoid any potentially sensitive topics.';
    } else if (safetyLevel === 'permissive') {
      instructions += '\n\nBe more flexible with content while maintaining basic safety guidelines.';
    }

    // Experimental features
    if (options.enableExperimentalFeatures) {
      instructions += '\n\nYou may use experimental features and cutting-edge capabilities.';
    }

    return instructions;
  }

  private getPersonalityInstructions(personality: string, style: string): string {
    const personalities = {
      professional: {
        concise: '\n\nMaintain a professional tone with brief, direct responses.',
        detailed: '\n\nMaintain a professional tone with comprehensive, well-structured responses.',
        explanatory: '\n\nMaintain a professional tone while thoroughly explaining concepts and reasoning.',
      },
      friendly: {
        concise: '\n\nBe warm and approachable with concise, helpful responses.',
        detailed: '\n\nBe warm, approachable, and conversational with detailed explanations.',
        explanatory: '\n\nBe friendly and enthusiastic while walking through explanations step by step.',
      },
      technical: {
        concise: '\n\nFocus on technical accuracy with precise, efficient responses.',
        detailed: '\n\nProvide technically accurate and comprehensive information.',
        explanatory: '\n\nFocus on technical accuracy while explaining complex concepts clearly.',
      },
      creative: {
        concise: '\n\nBe imaginative and innovative with creative, inspiring responses.',
        detailed: '\n\nExplore creative approaches and provide innovative, detailed solutions.',
        explanatory: '\n\nShare creative thinking processes and innovative problem-solving approaches.',
      },
    };

    return personalities[personality]?.[style] || personalities.friendly.detailed;
  }
}

export { advancedServerOptions, AdvancedMultiModalAgent };
```

## Key Concepts

### Option Types

```typescript
// Boolean - Toggle switch
{
  type: 'boolean',
  title: 'Feature Name',
  description: 'What this feature does',
  default: false
}

// Binary Enum - Two buttons
{
  type: 'string',
  enum: ['option1', 'option2'],
  default: 'option1'
}

// Multi Enum - Dropdown
{
  type: 'string',
  enum: ['option1', 'option2', 'option3'],
  default: 'option1'
}
```

### Accessing Options

```typescript
class MyAgent extends Agent {
  async run(input: string, runOptions?: { sessionId?: string }) {
    const sessionMetadata = this.getEventStream().getSessionMetadata(runOptions?.sessionId);
    const options = sessionMetadata?.agentOptions || {};
    const isFeatureEnabled = options.featureName || false;
    
    // Use options to customize behavior
    return super.run(input);
  }
}
```

## Best Practices

### 1. Clear Naming

```typescript
// ✅ Good - Clear, descriptive names
{
  enableDebugMode: { type: 'boolean', title: 'Debug Mode' },
  responseFormat: { type: 'string', enum: ['json', 'markdown'] }
}

// ❌ Avoid - Unclear abbreviations
{
  dbg: { type: 'boolean' },
  fmt: { type: 'string' }
}
```

### 2. Helpful Descriptions

```typescript
// ✅ Good - Clear descriptions
{
  verboseLogging: {
    type: 'boolean',
    title: 'Verbose Logging',
    description: 'Include detailed logs in responses for debugging',
    default: false
  }
}

// ❌ Avoid - Missing or vague descriptions
{
  verboseLogging: {
    type: 'boolean',
    title: 'Verbose Logging'
    // No description - users won't understand what this does
  }
}
```

### 3. Sensible Defaults

```typescript
// ✅ Good - Safe, commonly used defaults
{
  enableExperimentalFeatures: {
    type: 'boolean',
    default: false  // Safe default for experimental features
  },
  responseLanguage: {
    type: 'string',
    enum: ['english', 'chinese', 'japanese'],
    default: 'english'  // Most common default
  }
}
```

## Testing Your Implementation

1. Start your agent server with the new configuration
2. Open the UI and start a new chat session
3. Look for the "Options" button in the chat input area
4. Toggle different options and verify they affect agent behavior
5. Check that options persist across messages in the same session

## Common Patterns

### Feature Toggles
```typescript
if (options.enableWebSearch) {
  // Use web search tool
  const results = await this.callTool('web_search', { query });
}
```

### Conditional Instructions
```typescript
let instructions = this.instructions;
if (options.verboseMode) {
  instructions += '\n\nProvide detailed explanations for all responses.';
}
```

### Personality Switching
```typescript
const personality = options.personality || 'friendly';
const greeting = this.getGreeting(personality);
```

### Performance Tuning
```typescript
const maxSteps = parseInt(options.maxSteps) || 10;
// Apply step limit to reasoning process
```

## Next Steps

- Explore the [Agent Configuration documentation](/guide/basic/configuration)
- Learn about [Custom Tools](/examples/custom-tools)
- Check out [Server Integration](/examples/server-integration)
- Read about [Custom Hooks](/examples/custom-hooks)
