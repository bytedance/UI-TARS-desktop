[{"title":"Agent Server API","content":"#\n\nTarko Agent Server 的完整 API 参考。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的 API 文档，包括：\n\n * Server 构造函数选项\n * HTTP 端点\n * WebSocket 事件\n * 配置接口\n * 响应模式\n\n目前请参考 英文版 Agent Server API 文档 了解详细信息。","routePath":"/zh/api/agent-server","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":35}],"frontmatter":{"title":"Agent Server API","description":"Tarko Agent Server 的完整 API 参考"},"version":""},{"title":"Agent API","content":"#\n\n\n简介#\n\n@tarko/agent 是一个事件流驱动的元 Agent 框架，用于构建高效的多模态 Agent。\n\n\n何时使用？#\n\n此 Agent SDK 提供了低级别的编程 API，适用于从头构建 AI Agent，例如：\n\n * MCP Agent: 连接到 MCP 客户端\n * GUI Agent: 构建图形界面 Agent\n * 自定义 Agent: 为特定领域构建专门的 Agent\n\n\n安装#\n\nnpm install @tarko/agent\n\n\n\n特性#\n\n * 工具集成: 在 Agent 响应中轻松创建和调用工具\n * 事件流驱动: 标准事件流协议驱动，更高效地构建上下文和 UI\n * 原生流式: 原生流式传输让您实时了解 Agent 的输出\n * 多模态分析: 自动分析多模态工具结果，让您专注于构建 Agent\n * 强大的扩展能力: 丰富的生命周期设计允许您实现更高级的 Agent\n * 多模型提供商: 支持多种模型，支持高级配置和运行时选择\n * 多工具调用引擎: 多工具调用引擎让您更容易访问工具调用能力\n\n\n快速开始#\n\n创建 index.ts：\n\n\n\nconst locationTool = new Tool({\n  id: 'getCurrentLocation',\n  description: \"获取用户当前位置\",\n  parameters: z.object({}),\n  function: async () => {\n    return { location: 'Boston' };\n  },\n});\n\nconst weatherTool = new Tool({\n  id: 'getWeather',\n  description: '获取指定位置的天气信息',\n  parameters: z.object({\n    location: z.string().describe('位置名称，如城市名'),\n  }),\n  function: async (input) => {\n    const { location } = input;\n    return {\n      location,\n      temperature: '70°F (21°C)',\n      condition: 'Sunny',\n      precipitation: '10%',\n      humidity: '45%',\n      wind: '5 mph',\n    };\n  },\n});\n\nconst agent = new Agent({\n  tools: [locationTool, weatherTool],\n});\n\nasync function main() {\n  const response = await agent.run({\n    input: \"今天天气怎么样？\",\n  });\n  console.log(response);\n}\n\nmain();\n\n\n执行：\n\nnpx tsx index.ts\n\n\n\nAPI#\n\n\nAgent#\n\n定义 Agent 实例：\n\nconst agent = new Agent({\n  /* AgentOptions */\n});\n\n\nAgent 选项#\n\n * tools: Agent 可用的工具数组\n * systemPrompt: Agent 的系统提示\n * modelProvider: LLM 提供商的配置\n * stream: 启用流式响应（默认: false）\n * maxIterations: 最大迭代次数（默认: 10）\n\n\nTool#\n\n定义 Tool 实例：\n\n\n\nconst locationTool = new Tool({\n  id: 'getCurrentLocation',\n  description: \"获取用户当前位置\",\n  parameters: z.object({}),\n  function: async () => {\n    return { location: 'Boston' };\n  },\n});\n\n\nTool 选项#\n\n * id: 工具的唯一标识符\n * description: 工具功能描述\n * parameters: 工具参数的 Zod 模式\n * function: 实现工具逻辑的异步函数\n\n\n指南#\n\n\n流式模式#\n\n启用 stream: true：\n\nasync function main() {\n  const stream = await agent.run({\n    input: \"今天天气怎么样？\",\n    stream: true,\n  });\n\n  for await (const chunk of stream) {\n    console.log(JSON.stringify(chunk));\n  }\n}\n\n\n您将获得包含不同事件类型的流式输出：\n\n * assistant_message: 完整的助手消息\n * tool_call: 工具执行事件\n * tool_result: 工具执行结果\n * assistant_streaming_message: 流式消息块\n\n\n错误处理#\n\ntry {\n  const response = await agent.run({\n    input: \"今天天气怎么样？\",\n  });\n} catch (error) {\n  console.error('Agent 执行失败:', error);\n}\n\n\n\n高级配置#\n\nconst agent = new Agent({\n  tools: [weatherTool, locationTool],\n  systemPrompt: '你是一个有用的天气助手。',\n  modelProvider: {\n    apiKey: process.env.OPENAI_API_KEY,\n    baseURL: 'https://api.openai.com/v1',\n    model: 'gpt-4',\n    temperature: 0.7,\n    maxTokens: 1000,\n  },\n  maxIterations: 5,\n  stream: true,\n});\n\n\n更多高级使用模式，请参阅 Agent Hooks 文档。\n\n\n即将推出#\n\n详细的 API 文档正在完善中，敬请期待：\n\n * 完整的事件类型定义\n * 高级配置选项\n * 错误处理最佳实践\n * 性能优化指南\n\n目前请参考 英文版 Agent API 文档 了解完整信息。","routePath":"/zh/api/agent","lang":"zh","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"何时使用？","id":"何时使用","depth":2,"charIndex":61},{"text":"安装","id":"安装","depth":2,"charIndex":203},{"text":"特性","id":"特性","depth":2,"charIndex":236},{"text":"快速开始","id":"快速开始","depth":2,"charIndex":476},{"text":"API","id":"api","depth":2,"charIndex":1308},{"text":"Agent","id":"agent","depth":3,"charIndex":1315},{"text":"Agent 选项","id":"agent-选项","depth":4,"charIndex":1390},{"text":"Tool","id":"tool","depth":3,"charIndex":1547},{"text":"Tool 选项","id":"tool-选项","depth":4,"charIndex":1756},{"text":"指南","id":"指南","depth":2,"charIndex":1860},{"text":"流式模式","id":"流式模式","depth":3,"charIndex":1866},{"text":"错误处理","id":"错误处理","depth":3,"charIndex":2218},{"text":"高级配置","id":"高级配置","depth":3,"charIndex":2359},{"text":"即将推出","id":"即将推出","depth":2,"charIndex":2704}],"frontmatter":{"title":"Agent API","description":"Complete API reference for @tarko/agent"},"version":""},{"title":"Context Engineering API","content":"#\n\nTarko Context Engineering 的完整 API 参考。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的 API 文档，包括：\n\n * Context Engineering 配置\n * 压缩策略\n * 窗口算法\n * 持久化选项\n * 自定义实现\n\n目前请参考 英文版 Context Engineering API 文档 了解详细信息。","routePath":"/zh/api/context-engineering","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":42}],"frontmatter":{"title":"Context Engineering API","description":"Tarko Context Engineering 的完整 API 参考"},"version":""},{"title":"Agent Hooks API","content":"#\n\n\n简介#\n\nAgent Hooks 提供了一种强大的方式来扩展和自定义 Agent 在整个执行生命周期中的行为。BaseAgent\n类公开了一套全面的钩子，允许您拦截、修改和响应 Agent 执行期间的各种事件。\n\n\n概览#\n\n钩子                          描述\ninitialize()                Agent 初始化时调用\nonDispose()                 Agent 销毁时调用\nonPrepareRequest()          准备 LLM 请求前调用\nonLLMRequest()              发送请求到 LLM 前调用\nonLLMResponse()             从 LLM 接收响应后调用\nonLLMStreamingResponse()    LLM 流式响应时调用\nonProcessToolCalls()        拦截工具调用处理\nonBeforeToolCall()          执行工具前调用\nonAfterToolCall()           执行工具后调用\nonToolCallError()           工具执行失败时调用\nonEachAgentLoopStart()      每次 Agent 循环开始时调用\nonEachAgentLoopEnd()        每次 Agent 循环结束时调用\nonBeforeLoopTermination()   Agent 循环终止前调用\nonAgentLoopEnd()            整个 Agent 循环完成时调用\n\n\n基本示例#\n\n\ninitialize()#\n\nAgent 初始化期间调用，用于执行设置操作。\n\nclass CustomAgent extends BaseAgent {\n  async initialize(): Promise<void> {\n    // 执行耗时的设置操作\n    await this.connectToDatabase();\n    await this.loadConfiguration();\n    console.log('Agent 初始化成功');\n  }\n}\n\n\n\nonDispose()#\n\nAgent 销毁期间调用，用于清理资源。\n\nclass CustomAgent extends BaseAgent {\n  protected async onDispose(): Promise<void> {\n    // 清理资源\n    await this.closeConnections();\n    this.clearTimers();\n    console.log('Agent 销毁成功');\n  }\n}\n\n\n\nonPrepareRequest()#\n\n准备 LLM 请求前调用，允许动态修改系统提示和工具。\n\nclass CustomAgent extends BaseAgent {\n  onPrepareRequest(context: PrepareRequestContext): PrepareRequestResult {\n    let { systemPrompt, tools } = context;\n    \n    // 根据上下文修改系统提示\n    if (context.iteration > 3) {\n      systemPrompt += '\\n\\n注意：您正在第 ' + context.iteration + \n        ' 次迭代中。请专注于提供简洁的最终答案。';\n    }\n    \n    // 根据当前状态过滤工具\n    const filteredTools = tools.filter(tool => {\n      // 在后期迭代中禁用昂贵的工具\n      if (context.iteration > 5 && tool.name.includes('search')) {\n        return false;\n      }\n      return true;\n    });\n    \n    return {\n      systemPrompt,\n      tools: filteredTools,\n    };\n  }\n}\n\n\n\nonLLMRequest()#\n\n向 LLM 发送请求前触发，允许您检查或记录请求负载。\n\nclass CustomAgent extends BaseAgent {\n  async onLLMRequest(id: string, payload: LLMRequestHookPayload): Promise<void> {\n    console.log(`向 LLM 发送请求，会话 ${id}`);\n    console.log(`模型: ${payload.model}`);\n    console.log(`消息数量: ${payload.messages.length}`);\n    \n    // 记录令牌使用情况以进行监控\n    this.logTokenUsage(payload);\n  }\n}\n\n\n\nonBeforeToolCall()#\n\n执行工具前调用，允许您修改参数或添加验证。\n\nclass CustomAgent extends BaseAgent {\n  async onBeforeToolCall(\n    id: string,\n    toolCall: { toolCallId: string; name: string },\n    args: any\n  ): Promise<any> {\n    console.log(`执行工具: ${toolCall.name}`);\n    \n    // 添加验证\n    if (toolCall.name === 'fileOperation' && !this.hasFilePermission()) {\n      throw new Error('文件操作权限不足');\n    }\n    \n    // 修改参数\n    if (toolCall.name === 'searchWeb') {\n      args.maxResults = Math.min(args.maxResults || 10, 5);\n    }\n    \n    return args;\n  }\n}\n\n\n\nonAfterToolCall()#\n\n执行工具后调用，允许您修改结果或添加后处理。\n\nclass CustomAgent extends BaseAgent {\n  async onAfterToolCall(\n    id: string,\n    toolCall: { toolCallId: string; name: string },\n    result: any\n  ): Promise<any> {\n    console.log(`工具 ${toolCall.name} 执行完成`);\n    \n    // 后处理结果\n    if (toolCall.name === 'imageAnalysis') {\n      result.confidence = this.calculateConfidence(result);\n    }\n    \n    // 记录工具使用情况\n    this.logToolUsage(toolCall.name, result);\n    \n    return result;\n  }\n}\n\n\n\nonToolCallError()#\n\n工具执行导致错误时调用，允许您处理或转换错误。\n\nclass CustomAgent extends BaseAgent {\n  async onToolCallError(\n    id: string,\n    toolCall: { toolCallId: string; name: string },\n    error: any\n  ): Promise<any> {\n    console.error(`工具 ${toolCall.name} 执行失败:`, error);\n    \n    // 提供备用响应\n    if (toolCall.name === 'weatherAPI') {\n      return '天气信息当前不可用，请稍后再试。';\n    }\n    \n    // 转换错误消息\n    if (error.code === 'RATE_LIMIT') {\n      return '服务暂时繁忙，请稍等片刻后重试。';\n    }\n    \n    return `错误: ${error.message || error}`;\n  }\n}\n\n\n\n钩子执行顺序#\n\nflowchart TD\n    A[Agent 开始] --> B[initialize]\n    B --> C[Agent 循环开始]\n    C --> D[onEachAgentLoopStart]\n    D --> E[onPrepareRequest]\n    E --> F[onLLMRequest]\n    F --> G[LLM 调用]\n    G --> H[onLLMResponse / onLLMStreamingResponse]\n    H --> I{调用工具?}\n    I -->|是| J[onProcessToolCalls]\n    J --> K[onBeforeToolCall]\n    K --> L[工具执行]\n    L --> M{工具成功?}\n    M -->|是| N[onAfterToolCall]\n    M -->|否| O[onToolCallError]\n    N --> P[onEachAgentLoopEnd]\n    O --> P\n    I -->|否| P\n    P --> Q{继续循环?}\n    Q -->|是| D\n    Q -->|否| R[onBeforeLoopTermination]\n    R --> S{应该终止?}\n    S -->|是| T[onAgentLoopEnd]\n    S -->|否| D\n    T --> U[Agent 结束]\n    U --> V[onDispose]\n    V --> W[完成]\n\n\n\n即将推出#\n\n详细的 Hooks API 文档正在完善中，敬请期待：\n\n * 完整的钩子接口定义\n * 上下文对象详细说明\n * 钩子组合模式\n * 插件架构指南\n * 自定义钩子开发\n\n目前请参考 英文版 Hooks API 文档 了解完整信息。","routePath":"/zh/api/hooks","lang":"zh","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"概览","id":"概览","depth":2,"charIndex":111},{"text":"基本示例","id":"基本示例","depth":2,"charIndex":719},{"text":"`initialize()`","id":"initialize","depth":3,"charIndex":-1},{"text":"`onDispose()`","id":"ondispose","depth":3,"charIndex":-1},{"text":"`onPrepareRequest()`","id":"onpreparerequest","depth":3,"charIndex":-1},{"text":"`onLLMRequest()`","id":"onllmrequest","depth":3,"charIndex":-1},{"text":"`onBeforeToolCall()`","id":"onbeforetoolcall","depth":3,"charIndex":-1},{"text":"`onAfterToolCall()`","id":"onaftertoolcall","depth":3,"charIndex":-1},{"text":"`onToolCallError()`","id":"ontoolcallerror","depth":3,"charIndex":-1},{"text":"钩子执行顺序","id":"钩子执行顺序","depth":2,"charIndex":3781},{"text":"即将推出","id":"即将推出","depth":2,"charIndex":4470}],"frontmatter":{"title":"Agent Hooks API","description":"Complete API reference for Tarko Agent Hooks"},"version":""},{"title":"Tool Call Engine API","content":"#\n\nTarko Tool Call Engine 的完整 API 参考。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的 API 文档，包括：\n\n * Tool Call Engine 接口\n * 工具创建工具\n * 解析器配置\n * 错误处理类型\n * 自定义引擎实现\n\n目前请参考 英文版 Tool Call Engine API 文档 了解详细信息。","routePath":"/zh/api/tool-call-engine","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":39}],"frontmatter":{"title":"Tool Call Engine API","description":"Tarko Tool Call Engine 的完整 API 参考"},"version":""},{"title":"自定义 Hooks","content":"#\n\n使用自定义 Hooks 扩展 Agent 行为。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的自定义 Hooks 示例，包括：\n\n * Hook 组合模式\n * 插件开发\n * 监控和分析 Hooks\n * 性能优化 Hooks\n * 错误处理和恢复 Hooks\n\n目前请参考 英文版自定义 Hooks 文档 了解详细信息。","routePath":"/zh/examples/custom-hooks","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":29}],"frontmatter":{"title":"自定义 Hooks","description":"使用自定义 Hooks 扩展 Agent 行为"},"version":""},{"title":"自定义工具","content":"#\n\n为你的 Tarko Agent 构建高级自定义工具。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的自定义工具示例，包括：\n\n * 高级工具模式\n * 工具组合\n * 流式工具\n * 工具验证和错误处理\n * 工具测试策略\n\n目前请参考 英文版自定义工具文档 了解详细信息。","routePath":"/zh/examples/custom-tools","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":31}],"frontmatter":{"title":"自定义工具","description":"为你的 Tarko Agent 构建高级自定义工具"},"version":""},{"title":"入门示例","content":"#\n\n帮助你快速开始使用 Tarko 的实用示例。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的入门示例，包括：\n\n * 基础 Agent 示例\n * 天气 Agent\n * 计算器 Agent\n * 文件系统 Agent\n * 运行和测试示例\n\n目前请参考 英文版入门示例 了解详细信息。","routePath":"/zh/examples/getting-started","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":27}],"frontmatter":{"title":"入门示例","description":"帮助你快速开始使用 Tarko 的实用示例"},"version":""},{"title":"协议集成","content":"#\n\n与 Tarko 的 Agent Protocol 集成。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的协议集成示例，包括：\n\n * Event Stream 集成\n * 自定义 UI 开发\n * 协议扩展\n * 实时通信\n * 第三方集成\n\n目前请参考 英文版协议集成文档 了解详细信息。","routePath":"/zh/examples/protocol-integration","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":33}],"frontmatter":{"title":"协议集成","description":"与 Tarko 的 Agent Protocol 集成"},"version":""},{"title":"服务器集成","content":"#\n\n将 Tarko Agent 部署为生产服务器。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的服务器集成示例，包括：\n\n * 生产服务器部署\n * Docker 容器化\n * 负载均衡和扩展\n * 监控和日志\n * 认证和安全\n\n目前请参考 英文版服务器集成文档 了解详细信息。","routePath":"/zh/examples/server-integration","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":28}],"frontmatter":{"title":"服务器集成","description":"将 Tarko Agent 部署为生产服务器"},"version":""},{"title":"Agent Hooks","content":"#\n\n使用强大的钩子系统扩展和自定义 Agent 行为。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的 Agent Hooks 文档，包括：\n\n * 生命周期钩子\n * 消息处理钩子\n * 工具执行钩子\n * 自定义钩子实现\n * 插件系统\n\n目前请参考 英文版 Agent Hooks 文档 了解详细信息。","routePath":"/zh/guide/advanced/agent-hooks","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":30}],"frontmatter":{"title":"Agent Hooks","description":"使用强大的钩子系统扩展和自定义 Agent 行为"},"version":""},{"title":"Agent Protocol","content":"#\n\n了解 Tarko 的标准化通信协议。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的 Agent Protocol 文档，包括：\n\n * Event Stream 协议\n * Server Protocol\n * 事件类型\n * 协议扩展\n * 集成示例\n\n目前请参考 英文版 Agent Protocol 文档 了解详细信息。","routePath":"/zh/guide/advanced/agent-protocol","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":23}],"frontmatter":{"title":"Agent Protocol","description":"了解 Tarko 的标准化通信协议"},"version":""},{"title":"Agent Snapshot","content":"#\n\nAgent Snapshot 是一个强大的功能，允许你在运行时捕获 Agent 的完整状态并稍后回放。这对于调试、测试和确保确定性 Agent 行为至关重要。\n\n\n什么是 Agent Snapshot？#\n\nAgent Snapshot 捕获：\n\n * 完整的对话历史\n * 当前上下文状态\n * 工具调用历史和结果\n * Agent 配置\n * 环境状态\n\n\n创建快照#\n\n\n自动快照#\n\n启用自动快照创建：\n\n\n\nconst agent = new Agent({\n  ...config,\n  snapshot: {\n    enabled: true,\n    interval: 'on_tool_call', // 或 'on_message', 'manual'\n    storage: {\n      type: 'file',\n      path: './snapshots'\n    }\n  }\n});\n\n\n\n手动快照#\n\n程序化创建快照：\n\n// 创建快照\nconst snapshot = await agent.createSnapshot({\n  name: 'debug-session-1',\n  description: '问题工具调用之前'\n});\n\nconsole.log('快照已创建:', snapshot.id);\n\n\n\n快照结构#\n\n快照包含：\n\ninterface AgentSnapshot {\n  id: string;\n  timestamp: string;\n  name?: string;\n  description?: string;\n  \n  // Agent 状态\n  context: {\n    messages: Message[];\n    length: number;\n    metadata: Record<string, any>;\n  };\n  \n  // 配置\n  config: AgentConfig;\n  \n  // 环境\n  environment: {\n    variables: Record<string, string>;\n    workingDirectory: string;\n    platform: string;\n  };\n  \n  // 工具状态\n  tools: {\n    available: ToolDefinition[];\n    history: ToolCall[];\n  };\n}\n\n\n\n回放快照#\n\n\n加载和回放#\n\n\n\n// 加载快照\nconst snapshot = await loadSnapshot('./snapshots/debug-session-1.json');\n\n// 从快照创建 Agent\nconst agent = Agent.fromSnapshot(snapshot);\n\n// 从快照状态继续对话\nconst response = await agent.chat('接下来发生了什么？');\n\n\n\n带修改的回放#\n\n// 加载快照并修改配置\nconst snapshot = await loadSnapshot('./snapshots/debug-session-1.json');\n\n// 覆盖测试的模型设置\nsnapshot.config.model.temperature = 0.1;\nsnapshot.config.model.model = 'gpt-4';\n\nconst agent = Agent.fromSnapshot(snapshot);\n\n\n\n使用快照进行测试#\n\n\n基于快照的测试#\n\n\n\n\ntest('应该正确处理文件操作', async () => {\n  // 加载预录制的快照\n  const snapshot = await loadSnapshot('./test-snapshots/file-ops.json');\n  const agent = Agent.fromSnapshot(snapshot);\n  \n  // 回放场景\n  const response = await agent.chat('创建一个名为 test.txt 的新文件');\n  \n  // 断言预期行为\n  expect(response).toContain('文件创建成功');\n});\n\n\n\n回归测试#\n\n// 捕获基线行为\nconst baselineSnapshot = await agent.createSnapshot({\n  name: 'baseline-v1.0'\n});\n\n// 稍后，针对基线测试\nconst currentSnapshot = await agent.createSnapshot({\n  name: 'current-test'\n});\n\n// 比较快照\nconst diff = compareSnapshots(baselineSnapshot, currentSnapshot);\nif (diff.hasChanges) {\n  console.warn('行为已更改:', diff.changes);\n}\n\n\n\n快照管理#\n\n\n列出快照#\n\nconst snapshots = await agent.listSnapshots();\nsnapshots.forEach(snapshot => {\n  console.log(`${snapshot.name} (${snapshot.timestamp})`);\n});\n\n\n\n删除快照#\n\n// 删除特定快照\nawait agent.deleteSnapshot('debug-session-1');\n\n// 清理旧快照\nawait agent.cleanupSnapshots({\n  olderThan: '7d',\n  keepLatest: 10\n});\n\n\n\n最佳实践#\n\n\n何时创建快照#\n\n * 复杂操作之前\n * 成功工具调用之后\n * 调试问题时\n * 进行回归测试时\n\n\n命名约定#\n\n// 使用描述性名称\nconst snapshot = await agent.createSnapshot({\n  name: 'before-file-upload-v2.1',\n  description: '实施新文件上传逻辑之前的状态'\n});\n\n\n\n存储考虑#\n\n// 配置适当的存储\nconst agent = new Agent({\n  snapshot: {\n    storage: {\n      type: 'redis', // 用于生产\n      url: 'redis://localhost:6379',\n      ttl: 86400 // 24 小时\n    },\n    compression: true, // 减少存储大小\n    maxSnapshots: 100  // 限制存储使用\n  }\n});\n\n\n\n使用快照调试#\n\n\n捕获问题状态#\n\nagent.on('error', async (error) => {\n  // 错误时自动创建快照\n  const snapshot = await agent.createSnapshot({\n    name: `error-${Date.now()}`,\n    description: `错误: ${error.message}`\n  });\n  \n  console.log('错误快照已保存:', snapshot.id);\n});\n\n\n\n逐步调试#\n\n// 加载问题快照\nconst snapshot = await loadSnapshot('./snapshots/error-123.json');\nconst agent = Agent.fromSnapshot(snapshot);\n\n// 启用详细日志\nagent.setLogLevel('debug');\n\n// 带调试回放\nconst response = await agent.chat('从这里继续');\n","routePath":"/zh/guide/advanced/agent-snapshot","lang":"zh","toc":[{"text":"什么是 Agent Snapshot？","id":"什么是-agent-snapshot","depth":2,"charIndex":84},{"text":"创建快照","id":"创建快照","depth":2,"charIndex":183},{"text":"自动快照","id":"自动快照","depth":3,"charIndex":191},{"text":"手动快照","id":"手动快照","depth":3,"charIndex":419},{"text":"快照结构","id":"快照结构","depth":2,"charIndex":587},{"text":"回放快照","id":"回放快照","depth":2,"charIndex":1068},{"text":"加载和回放","id":"加载和回放","depth":3,"charIndex":1076},{"text":"带修改的回放","id":"带修改的回放","depth":3,"charIndex":1292},{"text":"使用快照进行测试","id":"使用快照进行测试","depth":2,"charIndex":1529},{"text":"基于快照的测试","id":"基于快照的测试","depth":3,"charIndex":1541},{"text":"回归测试","id":"回归测试","depth":3,"charIndex":1856},{"text":"快照管理","id":"快照管理","depth":2,"charIndex":2192},{"text":"列出快照","id":"列出快照","depth":3,"charIndex":2200},{"text":"删除快照","id":"删除快照","depth":3,"charIndex":2352},{"text":"最佳实践","id":"最佳实践","depth":2,"charIndex":2500},{"text":"何时创建快照","id":"何时创建快照","depth":3,"charIndex":2508},{"text":"命名约定","id":"命名约定","depth":3,"charIndex":2561},{"text":"存储考虑","id":"存储考虑","depth":3,"charIndex":2699},{"text":"使用快照调试","id":"使用快照调试","depth":2,"charIndex":2948},{"text":"捕获问题状态","id":"捕获问题状态","depth":3,"charIndex":2958},{"text":"逐步调试","id":"逐步调试","depth":3,"charIndex":3196}],"frontmatter":{"title":"Agent Snapshot","description":"捕获和回放 Agent 状态进行调试和测试"},"version":""},{"title":"Context Engineering","content":"#\n\nContext Engineering 是 Tarko 构建长程运行 Agent 的核心能力。它通过智能消息历史管理来管理上下文窗口并优化内存使用。\n\n\n什么是 Context Engineering？#\n\n传统 Agent 由于上下文窗口限制在长程任务中遇到困难。Tarko 的 Context Engineering 通过以下方式解决这个问题：\n\n * 消息历史管理：智能地将事件流转换为 LLM 上下文\n * 图像限制：控制上下文中的图像数量以防止溢出\n * 上下文感知：可配置的多模态内容上下文管理\n * 事件流处理：维护对话结构以获得最佳 LLM 上下文\n\n\n核心特性#\n\n\n1. 上下文感知配置#\n\n配置 Agent 如何管理上下文和多模态内容：\n\n\n\nconst agent = new Agent({\n  context: {\n    maxImagesCount: 5, // 限制上下文中的图像数量（默认：5）\n  }\n});\n\n\n\n2. 消息历史管理#\n\nMessageHistory 类自动将事件流转换为消息历史：\n\n// 来自 multimodal/tarko/agent/src/agent/message-history.ts\nconst messageHistory = new MessageHistory(\n  eventStream,\n  5 // maxImagesCount - 限制图像以防止上下文溢出\n);\n\nconst messages = messageHistory.toMessageHistory(\n  toolCallEngine,\n  systemPrompt,\n  tools\n);\n\n\n\n3. 图像上下文管理#\n\n控制在长对话中如何处理图像：\n\nconst agent = new Agent({\n  context: {\n    maxImagesCount: 10, // 允许上下文中最多 10 张图像\n  }\n});\n\n\n工作原理：\n\n * 超出限制的图像被替换为文本占位符\n * 保留最新的图像，省略最旧的图像\n * 在减少 token 使用的同时维护上下文结构\n\n\n配置选项#\n\n\n上下文感知配置#\n\n基于实际的 AgentContextAwarenessOptions 接口：\n\ninterface AgentContextAwarenessOptions {\n  /**\n   * 上下文中包含的最大图像数量\n   * 超出时，最旧的图像将被替换为文本占位符\n   * @default 5\n   */\n  maxImagesCount?: number;\n}\n\n\n\nAgent 配置#\n\nconst agent = new Agent({\n  context: {\n    maxImagesCount: 10, // 限制上下文中的图像\n  },\n  // 其他 Agent 选项...\n});\n\n\n\n最佳实践#\n\n\n1. 适当配置图像限制#\n\n对于文本密集型对话：\n\nconst agent = new Agent({\n  context: {\n    maxImagesCount: 3, // 为文本重点保留较少图像\n  },\n});\n\n\n对于视觉分析任务：\n\nconst agent = new Agent({\n  context: {\n    maxImagesCount: 15, // 允许更多图像用于视觉上下文\n  },\n});\n\n\n\n2. 监控上下文使用#\n\n使用事件流跟踪上下文变化：\n\nconst response = await agent.run({\n  input: \"分析这些图像\",\n  stream: true,\n});\n\nfor await (const event of response) {\n  if (event.type === 'user_message' || event.type === 'environment_input') {\n    console.log('上下文更新：', event.content);\n  }\n}\n\n\n\n3. 处理多模态内容#\n\n// 带图像的环境输入\nconst response = await agent.run({\n  input: \"你看到了什么？\",\n  environmentInput: {\n    content: [\n      { type: 'text', text: '当前屏幕：' },\n      { type: 'image_url', image_url: { url: 'data:image/png;base64,...' } }\n    ],\n    description: '屏幕截图'\n  }\n});\n\n\n\n高级用法#\n\n\n自定义消息历史处理#\n\n扩展 MessageHistory 类进行自定义上下文管理：\n\n\n\nclass CustomMessageHistory extends MessageHistory {\n  constructor(eventStream, maxImagesCount = 5) {\n    super(eventStream, maxImagesCount);\n  }\n\n  // 重写以添加带时间的自定义系统提示\n  getSystemPromptWithTime(instructions: string): string {\n    const customTime = new Date().toLocaleString('zh-CN', {\n      timeZone: 'Asia/Shanghai'\n    });\n    return `${instructions}\\n\\n当前时间（北京时间）：${customTime}`;\n  }\n}\n\n\n\n使用事件流#\n\n访问和操作事件流进行自定义上下文逻辑：\n\nconst agent = new Agent({ /* 选项 */ });\n\n// 获取事件流\nconst eventStream = agent.getEventStream();\n\n// 访问事件\nconst events = eventStream.getEvents();\nconsole.log(`总事件数：${events.length}`);\n\n// 过滤特定事件类型\nconst userMessages = events.filter(e => e.type === 'user_message');\nconst toolCalls = events.filter(e => e.type === 'tool_call');\n\n\n\n与 Agent Hooks 集成#\n\n使用 Agent Hooks 自定义上下文行为：\n\nconst agent = new Agent({\n  hooks: {\n    onBeforeToolCall: async (context) => {\n      // 在工具执行前记录上下文\n      console.log('工具调用前的上下文：', context.messages.length);\n    },\n    \n    onAfterToolCall: async (context) => {\n      // 监控工具执行后的上下文增长\n      console.log('工具调用后的上下文：', context.messages.length);\n    },\n    \n    onRetrieveTools: async (tools) => {\n      // 根据上下文大小过滤工具\n      const eventStream = agent.getEventStream();\n      const events = eventStream.getEvents();\n      \n      if (events.length > 50) {\n        // 为大型上下文减少工具\n        return tools.slice(0, 3);\n      }\n      return tools;\n    }\n  }\n});\n\n\n\n性能考虑#\n\n\n内存使用#\n\n * 根据可用内存配置 maxImagesCount\n * 监控长时间对话的事件流大小\n * 考虑在长时间使用后处理 Agent\n\n\n上下文窗口管理#\n\n * 图像消耗大量 token 空间\n * 文本占位符维护上下文结构\n * 平衡上下文丰富性和 token 限制\n\n\n最佳实践#\n\n * 使用环境输入处理临时上下文\n * 为文本重点任务限制图像\n * 在生产环境中监控事件流增长\n\n\n调试上下文问题#\n\n\n启用调试日志#\n\n\n\nconst agent = new Agent({\n  logLevel: LogLevel.DEBUG, // 启用详细日志\n});\n\n\n\n上下文检查#\n\n// 获取事件流进行分析\nconst eventStream = agent.getEventStream();\nconst events = eventStream.getEvents();\n\nconsole.log('总事件数：', events.length);\nconsole.log('事件类型：', [...new Set(events.map(e => e.type))]);\n\n// 计算上下文中的图像\nconst imageCount = events.reduce((count, event) => {\n  if (event.type === 'user_message' && Array.isArray(event.content)) {\n    return count + event.content.filter(part => \n      typeof part === 'object' && part.type === 'image_url'\n    ).length;\n  }\n  return count;\n}, 0);\n\nconsole.log('上下文中的图像：', imageCount);\n\n// 导出事件进行分析\nconst fs = require('fs');\nfs.writeFileSync('events-dump.json', JSON.stringify(events, null, 2));\n\n\n\n实际应用示例#\n\n\n视觉分析 Agent#\n\nconst visualAgent = new Agent({\n  context: {\n    maxImagesCount: 20, // 为视觉任务允许许多图像\n  },\n  instructions: '你是一个视觉分析专家。分析图像并提供详细见解。',\n});\n\n\n\n文本重点助手#\n\nconst textAssistant = new Agent({\n  context: {\n    maxImagesCount: 2, // 为文本重点最少图像\n  },\n  instructions: '你是一个专注于文本分析和生成的写作助手。',\n});\n\n\n\n长时间对话 Agent#\n\nconst conversationAgent = new Agent({\n  context: {\n    maxImagesCount: 8, // 混合内容的平衡\n  },\n  instructions: '你是一个用于扩展对话的有用助手。',\n});\n\n// 监控上下文增长\nsetInterval(() => {\n  const events = conversationAgent.getEventStream().getEvents();\n  console.log(`上下文事件：${events.length}`);\n}, 60000); // 每分钟检查一次\n\n\n\n下一步#\n\n * Tool Call Engine - 了解工具集成\n * Agent Protocol - 理解通信标准\n * Agent Hooks - 扩展 Agent 行为","routePath":"/zh/guide/advanced/context-engineering","lang":"zh","toc":[{"text":"什么是 Context Engineering？","id":"什么是-context-engineering","depth":2,"charIndex":79},{"text":"核心特性","id":"核心特性","depth":2,"charIndex":287},{"text":"1. 上下文感知配置","id":"1-上下文感知配置","depth":3,"charIndex":295},{"text":"2. 消息历史管理","id":"2-消息历史管理","depth":3,"charIndex":429},{"text":"3. 图像上下文管理","id":"3-图像上下文管理","depth":3,"charIndex":728},{"text":"配置选项","id":"配置选项","depth":2,"charIndex":923},{"text":"上下文感知配置","id":"上下文感知配置","depth":3,"charIndex":931},{"text":"Agent 配置","id":"agent-配置","depth":3,"charIndex":1126},{"text":"最佳实践","id":"最佳实践","depth":2,"charIndex":1245},{"text":"1. 适当配置图像限制","id":"1-适当配置图像限制","depth":3,"charIndex":1253},{"text":"2. 监控上下文使用","id":"2-监控上下文使用","depth":3,"charIndex":1470},{"text":"3. 处理多模态内容","id":"3-处理多模态内容","depth":3,"charIndex":1739},{"text":"高级用法","id":"高级用法","depth":2,"charIndex":2014},{"text":"自定义消息历史处理","id":"自定义消息历史处理","depth":3,"charIndex":2022},{"text":"使用事件流","id":"使用事件流","depth":3,"charIndex":2461},{"text":"与 Agent Hooks 集成","id":"与-agent-hooks-集成","depth":2,"charIndex":2816},{"text":"性能考虑","id":"性能考虑","depth":2,"charIndex":3464},{"text":"内存使用","id":"内存使用","depth":3,"charIndex":3472},{"text":"上下文窗口管理","id":"上下文窗口管理","depth":3,"charIndex":3546},{"text":"最佳实践","id":"最佳实践-1","depth":3,"charIndex":3615},{"text":"调试上下文问题","id":"调试上下文问题","depth":2,"charIndex":3673},{"text":"启用调试日志","id":"启用调试日志","depth":3,"charIndex":3684},{"text":"上下文检查","id":"上下文检查","depth":3,"charIndex":3766},{"text":"实际应用示例","id":"实际应用示例","depth":2,"charIndex":4409},{"text":"视觉分析 Agent","id":"视觉分析-agent","depth":3,"charIndex":4419},{"text":"文本重点助手","id":"文本重点助手","depth":3,"charIndex":4571},{"text":"长时间对话 Agent","id":"长时间对话-agent","depth":3,"charIndex":4715},{"text":"下一步","id":"下一步","depth":2,"charIndex":5022}],"frontmatter":{"title":"Context Engineering","description":"掌握长程运行 Agent 操作的先进上下文管理"},"version":""},{"title":"配置","content":"#\n\nTarko Agent 通过一个全面的配置对象进行配置，该对象定义了 Agent 的行为、能力和运行时设置。\n\n\n基础配置#\n\n\n\nconst agent = new Agent({\n  // Agent 身份\n  name: 'MyAgent',\n  id: 'my-agent-v1',\n  \n  // 模型配置\n  model: {\n    provider: 'openai',\n    id: 'gpt-4',\n    apiKey: process.env.OPENAI_API_KEY,\n  },\n  \n  // 系统提示（使用 instructions）\n  instructions: '你是一个有用的助手...',\n  \n  // 工具\n  tools: [],\n  \n  // 最大迭代次数\n  maxIterations: 10,\n  \n  // 温度参数\n  temperature: 0.7,\n});\n\n\n\n配置选项#\n\n\nAgent 身份#\n\n{\n  name: 'string',           // Agent 名称\n  id: 'string',             // Agent ID\n}\n\n\n\n模型配置#\n\n{\n  model: {\n    provider: 'openai' | 'anthropic' | 'volcengine',\n    id: 'string',           // 模型 ID，如 'gpt-4', 'claude-3-sonnet'\n    apiKey: 'string',\n    baseURL?: 'string',     // 自定义端点\n  },\n  temperature?: number,     // 0-1，默认：0.7\n  maxTokens?: number,       // 最大响应令牌\n  top_p?: number           // 核采样\n}\n\n\n\nContext Engineering#\n\n{\n  context: {\n    maxImagesCount: 5,      // 最大图片数量\n    // 其他上下文选项根据实际实现\n  }\n}\n\n\n\nTool Call Engine#\n\n{\n  toolCallEngine: 'native' | 'prompt_engineering' | 'structured_outputs'\n}\n\n\n\n其他配置选项#\n\n{\n  maxIterations: number,              // 最大循环次数，默认 1000\n  logLevel: LogLevel.DEBUG,           // 日志级别\n  enableStreamingToolCallEvents: boolean,  // 启用流式工具调用事件\n}\n\n\n\n环境变量#\n\nTarko 支持通过环境变量进行配置：\n\n# 模型配置\nTARKO_MODEL_PROVIDER=openai\nTARKO_MODEL_API_KEY=your-api-key\nTARKO_MODEL_NAME=gpt-4\n\n# Agent 配置\nTARKO_AGENT_NAME=MyAgent\nTARKO_AGENT_DESCRIPTION=\"一个有用的助手\"\n\n# 上下文配置\nTARKO_CONTEXT_MAX_LENGTH=32000\nTARKO_CONTEXT_COMPRESSION_RATIO=0.8\n\n\n\n配置文件#\n\n你也可以使用配置文件（tarko.config.js）：\n\nmodule.exports = {\n  name: 'MyAgent',\n  description: '一个有用的助手',\n  model: {\n    provider: 'openai',\n    apiKey: process.env.OPENAI_API_KEY,\n    model: 'gpt-4'\n  },\n  tools: [\n    '@tarko/tools/file-system',\n    '@tarko/tools/browser'\n  ]\n};\n\n\n\n验证#\n\nTarko 在启动时验证配置并提供有用的错误消息：\n\ntry {\n  const agent = new Agent(config);\n} catch (error) {\n  console.error('配置错误:', error.message);\n}\n","routePath":"/zh/guide/basic/configuration","lang":"zh","toc":[{"text":"基础配置","id":"基础配置","depth":2,"charIndex":59},{"text":"配置选项","id":"配置选项","depth":2,"charIndex":420},{"text":"Agent 身份","id":"agent-身份","depth":3,"charIndex":428},{"text":"模型配置","id":"模型配置","depth":3,"charIndex":526},{"text":"Context Engineering","id":"context-engineering","depth":3,"charIndex":848},{"text":"Tool Call Engine","id":"tool-call-engine","depth":3,"charIndex":953},{"text":"其他配置选项","id":"其他配置选项","depth":3,"charIndex":1052},{"text":"环境变量","id":"环境变量","depth":2,"charIndex":1227},{"text":"配置文件","id":"配置文件","depth":2,"charIndex":1496},{"text":"验证","id":"验证","depth":2,"charIndex":1776}],"frontmatter":{"title":"配置","description":"配置你的 Tarko Agent"},"version":""},{"title":"事件流","content":"#\n\nTarko 基于 事件驱动架构 构建，所有 Agent 交互都表示为流中的事件。这使得实时监控、调试和上下文管理等强大功能成为可能。\n\n\n事件类型#\n\nTarko 定义了几种核心事件类型：\n\n\n用户事件#\n\n{\n  type: 'user_message',\n  content: '你好，可以帮助我吗？',\n  timestamp: '2025-01-01T00:00:00Z'\n}\n\n\n\nAgent 事件#\n\n{\n  type: 'assistant_message',\n  content: '我很乐意帮助你！',\n  timestamp: '2025-01-01T00:00:01Z'\n}\n\n\n\n工具事件#\n\n{\n  type: 'tool_call',\n  toolCall: {\n    id: 'call_123',\n    function: {\n      name: 'getWeather',\n      arguments: '{\"location\": \"Boston\"}'\n    }\n  },\n  timestamp: '2025-01-01T00:00:02Z'\n}\n\n{\n  type: 'tool_result',\n  toolCallId: 'call_123',\n  toolName: 'getWeather',\n  result: { temperature: 72, condition: 'sunny' },\n  timestamp: '2025-01-01T00:00:03Z'\n}\n\n\n\n系统事件#\n\n{\n  type: 'context_updated',\n  data: {\n    reason: 'compression',\n    newLength: 8000,\n    timestamp: '2025-01-01T00:00:04Z'\n  }\n}\n\n\n\n监听事件#\n\n通过事件流处理器订阅事件：\n\n\n\nconst agent = new Agent(config);\nconst eventStream = agent.getEventStream();\n\n// 监听所有事件\neventStream.on('event', (event) => {\n  console.log('事件:', event.type);\n});\n\n// 监听特定事件类型\neventStream.on('tool_call', (event) => {\n  console.log('调用工具:', event.toolCall.function.name);\n});\n\neventStream.on('assistant_message', (event) => {\n  console.log('Agent 响应:', event.content);\n});\n\n\n\n事件流处理#\n\n实时处理事件：\n\nconst eventProcessor = {\n  async processEvent(event) {\n    switch (event.type) {\n      case 'tool_call':\n        // 记录工具使用\n        await logToolUsage(event.toolCall);\n        break;\n        \n      case 'assistant_message':\n        // 更新 UI\n        await updateUI(event.content);\n        break;\n        \n      case 'error':\n        // 处理错误\n        await handleError(event.error);\n        break;\n    }\n  }\n};\n\neventStream.on('event', eventProcessor.processEvent);\n\n\n\n服务器发送事件 (SSE)#\n\n对于 Web 应用，事件可以通过 SSE 流式传输：\n\n// 服务器\napp.get('/agent/stream', (req, res) => {\n  res.writeHead(200, {\n    'Content-Type': 'text/event-stream',\n    'Cache-Control': 'no-cache',\n    'Connection': 'keep-alive'\n  });\n\n  const eventStream = agent.getEventStream();\n  eventStream.on('event', (event) => {\n    res.write(`data: ${JSON.stringify(event)}\\n\\n`);\n  });\n});\n\n\n// 客户端\nconst eventSource = new EventSource('/agent/stream');\n\neventSource.onmessage = (event) => {\n  const agentEvent = JSON.parse(event.data);\n  handleAgentEvent(agentEvent);\n};\n\n\n\n事件持久化#\n\n事件可以持久化以供回放和分析：\n\nconst agent = new Agent({\n  ...config,\n  persistence: {\n    enabled: true,\n    storage: 'file', // 或 'redis', 'mongodb'\n    path: './agent-events.jsonl'\n  }\n});\n\n\n\n事件过滤#\n\n基于条件过滤事件：\n\nagent.on('event', (event) => {\n  // 只处理工具相关事件\n  if (event.type.startsWith('tool_')) {\n    processToolEvent(event);\n  }\n});\n","routePath":"/zh/guide/basic/event-stream","lang":"zh","toc":[{"text":"事件类型","id":"事件类型","depth":2,"charIndex":71},{"text":"用户事件","id":"用户事件","depth":3,"charIndex":99},{"text":"Agent 事件","id":"agent-事件","depth":3,"charIndex":198},{"text":"工具事件","id":"工具事件","depth":3,"charIndex":304},{"text":"系统事件","id":"系统事件","depth":3,"charIndex":671},{"text":"监听事件","id":"监听事件","depth":2,"charIndex":812},{"text":"事件流处理","id":"事件流处理","depth":2,"charIndex":1211},{"text":"服务器发送事件 (SSE)","id":"服务器发送事件-sse","depth":2,"charIndex":1693},{"text":"事件持久化","id":"事件持久化","depth":2,"charIndex":2252},{"text":"事件过滤","id":"事件过滤","depth":2,"charIndex":2441}],"frontmatter":{"title":"事件流","description":"理解 Tarko 的事件驱动架构"},"version":""},{"title":"模型提供商","content":"#\n\nTarko 遵循 OpenAI Compatible 协议连接任意 LLM 提供商，包括 Volcengine、OpenAI、Anthropic、Gemini\n等。\n\n\n配置#\n\n在 Agent 配置中配置你的模型提供商：\n\n\n\nconst agent = new Agent({\n  model: {\n    provider: 'openai',\n    apiKey: process.env.OPENAI_API_KEY,\n    model: 'gpt-4'\n  }\n});\n\n\n\n支持的提供商#\n\n\nOpenAI#\n\n{\n  provider: 'openai',\n  id: 'gpt-4',\n  apiKey: 'your-api-key',\n}\n\n\n\nAnthropic#\n\n{\n  provider: 'anthropic',\n  id: 'claude-3-5-sonnet-20241022',\n  apiKey: 'your-api-key',\n}\n\n\n\nVolcengine（火山引擎）#\n\n{\n  provider: 'volcengine',\n  id: 'ep-20250510145437-5sxhs',  // 或 'doubao-1.5-thinking-vision-pro'\n  apiKey: 'your-api-key',\n}\n\n\n\n自定义提供商#\n\n你也可以使用任何 OpenAI 兼容的端点：\n\n{\n  provider: 'openai',  // 使用 openai 兼容协议\n  baseURL: 'https://your-endpoint.com/v1',\n  id: 'your-model',\n  apiKey: 'your-api-key',\n}\n","routePath":"/zh/guide/basic/model-provider","lang":"zh","toc":[{"text":"配置","id":"配置","depth":2,"charIndex":87},{"text":"支持的提供商","id":"支持的提供商","depth":2,"charIndex":248},{"text":"OpenAI","id":"openai","depth":3,"charIndex":258},{"text":"Anthropic","id":"anthropic","depth":3,"charIndex":337},{"text":"Volcengine（火山引擎）","id":"volcengine火山引擎","depth":3,"charIndex":443},{"text":"自定义提供商","id":"自定义提供商","depth":2,"charIndex":593}],"frontmatter":{"title":"模型提供商","description":"使用 Tarko 连接不同的 LLM 提供商"},"version":""},{"title":"Tool Call Engine","content":"#\n\nTarko 的 Tool Call Engine 决定了 Agent 如何处理和执行工具调用。不同的引擎为各种 LLM 提供商和使用场景提供兼容性。\n\n\n概述#\n\nTool Call Engine 处理：\n\n * 函数调用解析：如何从 LLM 响应中提取工具调用\n * 提供商兼容性：与具有不同工具调用能力的模型兼容\n * 执行策略：如何调用工具和处理结果\n * 错误处理：管理失败的工具调用和重试\n\n\n可用的引擎类型#\n\n基于源代码中实际的 ToolCallEngineType：\n\n\n1. Native 引擎#\n\n最适合：支持原生函数调用的模型（GPT-4、Claude 3.5 等）\n\n\n\nconst agent = new Agent({\n  toolCallEngine: 'native',\n  model: {\n    provider: 'openai',\n    id: 'gpt-4o',\n    apiKey: process.env.OPENAI_API_KEY,\n  },\n  tools: [weatherTool],\n});\n\n\n工作原理：\n\n * 使用模型的内置函数调用能力\n * 在 API 请求中将工具作为函数定义发送\n * 解析结构化的函数调用响应\n * 对支持的模型最可靠和高效\n\n\n2. Prompt Engineering 引擎#\n\n最适合：没有原生函数调用或需要自定义解析的模型\n\nconst agent = new Agent({\n  toolCallEngine: 'prompt_engineering',\n  model: {\n    provider: 'volcengine', \n    id: 'ep-20250510145437-5sxhs',\n    apiKey: process.env.ARK_API_KEY,\n  },\n  tools: [weatherTool],\n});\n\n\n工作原理：\n\n * 在系统提示中嵌入工具描述\n * 指示模型以特定格式输出工具调用\n * 使用正则表达式/模式从文本响应中解析工具调用\n * 为任何基于文本的模型提供后备兼容性\n\n\n3. Structured Outputs 引擎#\n\n最适合：支持结构化输出但不支持函数调用的模型\n\nconst agent = new Agent({\n  toolCallEngine: 'structured_outputs',\n  model: {\n    provider: 'anthropic',\n    id: 'claude-3-5-sonnet-20241022', \n    apiKey: process.env.ANTHROPIC_API_KEY,\n  },\n  tools: [weatherTool],\n});\n\n\n工作原理：\n\n * 使用结构化输出模式来强制工具调用格式\n * 比提示工程在解析方面更可靠\n * 减少解析错误并提高一致性\n * 适用于支持 JSON 模式约束的模型\n\n\n引擎选择指南#\n\n\n自动选择#\n\nTarko 可以自动为您的模型选择最佳引擎：\n\n// Tarko 将根据模型提供商选择最优引擎\nconst agent = new Agent({\n  // 未指定 toolCallEngine - 自动选择\n  model: {\n    provider: 'openai',\n    id: 'gpt-4o',\n    apiKey: process.env.OPENAI_API_KEY,\n  },\n  tools: [weatherTool],\n});\n\n\n\n手动选择#\n\n根据您的需求明确选择：\n\n// 强制使用提示工程进行自定义控制\nconst agent = new Agent({\n  toolCallEngine: 'prompt_engineering',\n  model: {\n    provider: 'openai', // 即使对于 OpenAI，也使用提示工程\n    id: 'gpt-4o',\n    apiKey: process.env.OPENAI_API_KEY,\n  },\n  tools: [weatherTool],\n});\n\n\n\n引擎比较#\n\n引擎                   可靠性     性能      兼容性     使用场景\nnative               ⭐⭐⭐⭐⭐   ⭐⭐⭐⭐⭐   ⭐⭐⭐     支持模型的生产环境\nstructured_outputs   ⭐⭐⭐⭐    ⭐⭐⭐⭐    ⭐⭐⭐⭐    支持模式的模型\nprompt_engineering   ⭐⭐⭐     ⭐⭐⭐     ⭐⭐⭐⭐⭐   通用兼容性\n\n\n源代码中的真实示例#\n\n\n基本 Tool Call Engine 使用#\n\n来自 multimodal/tarko/agent/examples/tool-calls/basic.ts：\n\n\n\nconst agent = new Agent({\n  model: {\n    provider: 'volcengine',\n    id: 'ep-20250510145437-5sxhs',\n    apiKey: process.env.ARK_API_KEY,\n  },\n  tools: [locationTool, weatherTool],\n  logLevel: LogLevel.DEBUG,\n  // toolCallEngine 将根据模型能力自动选择\n});\n\n\n\n流式 Tool Call Engine#\n\n来自 multimodal/tarko/agent/examples/streaming/tool-calls.ts：\n\nconst agent = new Agent({\n  model: {\n    provider: 'volcengine',\n    id: 'ep-20250510145437-5sxhs',\n    apiKey: process.env.ARK_API_KEY,\n  },\n  tools: [locationTool, weatherTool],\n  toolCallEngine: 'native',\n  enableStreamingToolCallEvents: true,\n});\n\n\n\n调试 Tool Call Engine#\n\n\n启用调试日志#\n\n\n\nconst agent = new Agent({\n  toolCallEngine: 'prompt_engineering',\n  logLevel: LogLevel.DEBUG, // 查看详细的工具调用解析\n  tools: [weatherTool],\n});\n\n\n\n监控工具调用事件#\n\nconst response = await agent.run({\n  input: \"天气如何？\",\n  stream: true,\n});\n\nfor await (const event of response) {\n  if (event.type === 'tool_call') {\n    console.log('工具调用:', event.toolCall.function.name);\n  }\n  if (event.type === 'tool_result') {\n    console.log('工具结果:', event.result);\n  }\n}\n\n\n\n故障排除#\n\n\n常见问题#\n\n工具调用未被检测到：\n\n * 检查模型是否支持所选的引擎类型\n * 尝试切换到 prompt_engineering 以获得更广泛的兼容性\n * 验证工具描述是否清晰和具体\n\n提示工程的解析错误：\n\n * 模型可能没有遵循预期格式\n * 如果模型支持模式，尝试 structured_outputs\n * 简化工具参数模式\n\n性能问题：\n\n * native 引擎对支持的模型最快\n * prompt_engineering 增加解析开销\n * 考虑为昂贵的工具操作使用缓存\n\n\n引擎选择决策树#\n\n您的模型是否支持原生函数调用？\n├─ 是 → 使用 'native'（推荐）\n└─ 否\n   ├─ 是否支持结构化输出？\n   │  ├─ 是 → 使用 'structured_outputs'\n   │  └─ 否 → 使用 'prompt_engineering'\n   └─ 需要自定义解析逻辑？\n      └─ 考虑实现自定义引擎\n\n\n\n下一步#\n\n * 工具 - 学习如何创建工具\n * 配置 - 配置工具调用引擎\n * 事件流 - 监控工具调用事件","routePath":"/zh/guide/basic/tool-call-engine","lang":"zh","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":79},{"text":"可用的引擎类型","id":"可用的引擎类型","depth":2,"charIndex":204},{"text":"1. Native 引擎","id":"1-native-引擎","depth":3,"charIndex":246},{"text":"2. Prompt Engineering 引擎","id":"2-prompt-engineering-引擎","depth":3,"charIndex":564},{"text":"3. Structured Outputs 引擎","id":"3-structured-outputs-引擎","depth":3,"charIndex":920},{"text":"引擎选择指南","id":"引擎选择指南","depth":2,"charIndex":1278},{"text":"自动选择","id":"自动选择","depth":3,"charIndex":1288},{"text":"手动选择","id":"手动选择","depth":3,"charIndex":1529},{"text":"引擎比较","id":"引擎比较","depth":2,"charIndex":1786},{"text":"源代码中的真实示例","id":"源代码中的真实示例","depth":2,"charIndex":2004},{"text":"基本 Tool Call Engine 使用","id":"基本-tool-call-engine-使用","depth":3,"charIndex":2017},{"text":"流式 Tool Call Engine","id":"流式-tool-call-engine","depth":3,"charIndex":2348},{"text":"调试 Tool Call Engine","id":"调试-tool-call-engine","depth":2,"charIndex":2685},{"text":"启用调试日志","id":"启用调试日志","depth":3,"charIndex":2708},{"text":"监控工具调用事件","id":"监控工具调用事件","depth":3,"charIndex":2859},{"text":"故障排除","id":"故障排除","depth":2,"charIndex":3165},{"text":"常见问题","id":"常见问题","depth":3,"charIndex":3173},{"text":"引擎选择决策树","id":"引擎选择决策树","depth":3,"charIndex":3420},{"text":"下一步","id":"下一步","depth":2,"charIndex":3604}],"frontmatter":{"title":"Tool Call Engine","description":"理解 Tarko 的 Tool Call Engine 类型和选择"},"version":""},{"title":"工具","content":"#\n\n工具是使 Agent 能够与外部世界交互的核心能力。Tarko 支持遵循 OpenAI Function Call 协议的各种类型工具。\n\n\n工具定义#\n\n所有工具都使用 Tool 类创建，遵循 OpenAI Function Call 协议。\n\n\n基本工具示例#\n\n\n\n// 获取当前位置的工具\nconst locationTool = new Tool({\n  id: 'getCurrentLocation',\n  description: \"获取用户当前位置\",\n  parameters: z.object({}),\n  function: async () => {\n    return { location: 'Boston' };\n  },\n});\n\n// 获取天气信息的工具\nconst weatherTool = new Tool({\n  id: 'getWeather',\n  description: '获取指定位置的天气信息',\n  parameters: z.object({\n    location: z.string().describe('位置名称，如城市名'),\n  }),\n  function: async (input) => {\n    const { location } = input;\n    return {\n      location,\n      temperature: '70°F (21°C)',\n      condition: 'Sunny',\n      precipitation: '10%',\n      humidity: '45%',\n      wind: '5 mph',\n    };\n  },\n});\n\n\n\n使用 Zod Schema#\n\nTarko 推荐使用 Zod 来定义工具参数，提供类型安全和运行时验证：\n\n\n\n// 复杂参数的工具\nconst searchTool = new Tool({\n  id: 'search',\n  description: '在互联网上搜索信息',\n  parameters: z.object({\n    query: z.string().describe('搜索查询'),\n    maxResults: z.number().optional().describe('最大结果数，默认 10'),\n    language: z.enum(['zh', 'en']).optional().describe('搜索语言'),\n  }),\n  function: async (input) => {\n    const { query, maxResults = 10, language = 'zh' } = input;\n    // 实现搜索逻辑\n    return {\n      results: [\n        { title: '搜索结果 1', url: 'https://example.com/1' },\n        { title: '搜索结果 2', url: 'https://example.com/2' },\n      ],\n      totalResults: maxResults\n    };\n  },\n});\n\n\n\n使用 JSON Schema#\n\n也可以使用标准 JSON Schema：\n\nconst fileTool = new Tool({\n  id: 'readFile',\n  description: '读取文件内容',\n  parameters: {\n    type: 'object',\n    properties: {\n      path: {\n        type: 'string',\n        description: '文件路径'\n      },\n      encoding: {\n        type: 'string',\n        enum: ['utf8', 'base64'],\n        description: '文件编码'\n      }\n    },\n    required: ['path']\n  },\n  function: async (params: { path: string; encoding?: string }) => {\n    // 实现文件读取逻辑\n    return { content: '文件内容', size: 1024 };\n  },\n});\n\n\n\n注册工具到 Agent#\n\n将工具添加到 Agent：\n\n\n\nconst agent = new Agent({\n  model: {\n    provider: 'openai',\n    id: 'gpt-4',\n    apiKey: process.env.OPENAI_API_KEY,\n  },\n  tools: [\n    locationTool,\n    weatherTool,\n    searchTool,\n    fileTool\n  ]\n});\n\n// 也可以动态注册工具\nagent.registerTool(newTool);\n\n// 获取所有已注册的工具\nconst allTools = agent.getTools();\nconsole.log('已注册工具:', allTools.map(t => t.name));\n\n\n\n工具执行示例#\n\n完整的工具使用示例：\n\n// 来自真实示例：multimodal/tarko/agent/examples/tool-calls/basic.ts\nconst agent = new Agent({\n  model: {\n    provider: 'volcengine',\n    id: 'ep-20250510145437-5sxhs',\n    apiKey: process.env.ARK_API_KEY,\n  },\n  tools: [locationTool, weatherTool],\n});\n\nconst response = await agent.run(\"今天天气怎么样？\");\nconsole.log(response);\n\n\n\n","routePath":"/zh/guide/basic/tools","lang":"zh","toc":[{"text":"工具定义","id":"工具定义","depth":2,"charIndex":73},{"text":"基本工具示例","id":"基本工具示例","depth":3,"charIndex":127},{"text":"使用 Zod Schema","id":"使用-zod-schema","depth":2,"charIndex":753},{"text":"使用 JSON Schema","id":"使用-json-schema","depth":2,"charIndex":1407},{"text":"注册工具到 Agent","id":"注册工具到-agent","depth":2,"charIndex":1934},{"text":"工具执行示例","id":"工具执行示例","depth":2,"charIndex":2317}],"frontmatter":{"title":"工具","description":"为你的 Tarko Agent 添加工具"},"version":""},{"title":"故障排除","content":"#\n\n使用 Tarko Agent 时的常见问题和解决方案。\n\n\n安装问题#\n\n\nNode.js 版本#\n\n问题：安装失败，出现 Node.js 版本错误。\n\n解决方案：确保使用 Node.js 18 或更高版本：\n\nnode --version  # 应该是 18.0.0 或更高\nnpm --version   # 应该是 8.0.0 或更高\n\n\n\n包安装#\n\n问题：npm install 失败，出现依赖冲突。\n\n解决方案：清除缓存并重新安装：\n\nnpm cache clean --force\nrm -rf node_modules package-lock.json\nnpm install\n\n\n\n运行时问题#\n\n\nAgent 无法启动#\n\n问题：Agent 启动失败，出现配置错误。\n\n解决方案：检查你的 tarko.config.ts：\n\n// 确保所有必需字段都存在\nexport default defineConfig({\n  agent: {\n    name: 'MyAgent',        // 必需\n    systemPrompt: '...',    // 必需\n  },\n  modelProvider: {\n    provider: 'openai',     // 必需\n    apiKey: process.env.OPENAI_API_KEY, // 必需\n  },\n});\n\n\n\nAPI 密钥问题#\n\n问题：\"无效的 API 密钥\" 或认证错误。\n\n解决方案：验证环境变量：\n\n# 检查 API 密钥是否已设置\necho $OPENAI_API_KEY\n\n# 如果缺失，设置 API 密钥\nexport OPENAI_API_KEY=\"your-api-key-here\"\n\n\n\n端口已被占用#\n\n问题：\"端口 3000 已被占用\" 错误。\n\n解决方案：使用不同的端口：\n\n# 选项 1：终止现有进程\nlsof -ti:3000 | xargs kill -9\n\n# 选项 2：使用不同端口\nAGENT_PORT=3001 tarko run\n\n\n\n工具问题#\n\n\n找不到工具#\n\n问题：\"找不到工具 'xyz'\" 错误。\n\n解决方案：确保工具已正确注册：\n\n\n\nexport default defineConfig({\n  tools: [\n    searchTool(),  // 确保工具已包含\n  ],\n});\n\n\n\n浏览器工具问题#\n\n问题：浏览器工具启动失败。\n\n解决方案：安装浏览器依赖：\n\n# Ubuntu/Debian\nsudo apt-get install -y chromium-browser\n\n# macOS\nbrew install chromium\n\n# 或使用无头模式\nBROWSER_HEADLESS=true tarko run\n\n\n\n文件系统权限#\n\n问题：文件系统工具无法访问文件。\n\n解决方案：检查文件权限和工作区配置：\n\nexport default defineConfig({\n  tools: [\n    fileSystemTool({\n      allowedPaths: ['/path/to/workspace'],  // 指定允许的路径\n      readonly: false,                       // 允许写操作\n    }),\n  ],\n});\n\n\n\n性能问题#\n\n\n响应时间慢#\n\n问题：Agent 响应非常慢。\n\n解决方案：优化配置：\n\nexport default defineConfig({\n  modelProvider: {\n    provider: 'openai',\n    model: 'gpt-4o-mini',  // 使用更快的模型\n    temperature: 0.1,      // 降低温度以获得更快响应\n    maxTokens: 1000,       // 限制响应长度\n  },\n  agent: {\n    maxIterations: 5,      // 限制思考循环\n    timeout: 30000,        // 30 秒超时\n  },\n});\n\n\n\n内存使用#\n\n问题：内存消耗过高。\n\n解决方案：配置上下文限制：\n\nexport default defineConfig({\n  agent: {\n    maxContextLength: 8000,    // 限制上下文大小\n    contextStrategy: 'sliding', // 使用滑动窗口\n  },\n});\n\n\n\n开发问题#\n\n\n热重载不工作#\n\n问题：更改不会在开发模式下触发重载。\n\n解决方案：检查文件监听：\n\n# 增加文件监听限制（Linux）\necho fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p\n\n# 重启开发服务器\nnpm run dev\n\n\n\nTypeScript 错误#\n\n问题：TypeScript 编译错误。\n\n解决方案：检查 tsconfig.json 和依赖：\n\n# 安装类型定义\nnpm install --save-dev @types/node\n\n# 检查 TypeScript 版本\nnpx tsc --version\n\n# 手动编译查看错误\nnpx tsc --noEmit\n\n\n\n调试#\n\n\n启用调试日志#\n\n# 设置日志级别为调试\nAGENT_LOG_LEVEL=debug tarko run\n\n# 或在配置中\nexport default defineConfig({\n  agent: {\n    logLevel: 'debug',\n  },\n});\n\n\n\n检查 Agent 状态#\n\n\n\nexport default defineConfig({\n  hooks: {\n    onBeforeToolCall: (context) => {\n      console.log('工具调用:', context.toolName, context.args);\n    },\n    onAfterToolCall: (context) => {\n      console.log('工具结果:', context.result);\n    },\n  },\n});\n\n\n\n网络问题#\n\n# 测试 API 连接\ncurl -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n     https://api.openai.com/v1/models\n\n# 检查代理设置\necho $HTTP_PROXY\necho $HTTPS_PROXY\n\n\n\n获取帮助#\n\n\n日志文件#\n\n检查日志文件获取详细错误信息：\n\n# 默认日志位置\ntail -f ~/.tarko/logs/agent.log\n\n# 或自定义日志位置\ntail -f ./logs/tarko.log\n\n\n\n常见错误代码#\n\n错误代码           描述         解决方案\nECONNREFUSED   连接被拒绝      检查网络/API 端点\nENOTFOUND      DNS 解析失败   检查网络连接\nEACCES         权限被拒绝      检查文件/目录权限\nEMFILE         打开文件过多     增加文件描述符限制\n\n\n社区支持#\n\n * GitHub Issues\n * 文档\n * Discord 社区\n\n\n下一步#\n\n如果你仍然遇到问题：\n\n 1. 查看配置指南\n 2. 查看Agent Hooks进行调试\n 3. 探索Agent Hooks进行调试","routePath":"/zh/guide/basic/troubleshooting","lang":"zh","toc":[{"text":"安装问题","id":"安装问题","depth":2,"charIndex":32},{"text":"Node.js 版本","id":"nodejs-版本","depth":3,"charIndex":40},{"text":"包安装","id":"包安装","depth":3,"charIndex":176},{"text":"运行时问题","id":"运行时问题","depth":2,"charIndex":303},{"text":"Agent 无法启动","id":"agent-无法启动","depth":3,"charIndex":312},{"text":"API 密钥问题","id":"api-密钥问题","depth":3,"charIndex":616},{"text":"端口已被占用","id":"端口已被占用","depth":3,"charIndex":766},{"text":"工具问题","id":"工具问题","depth":2,"charIndex":901},{"text":"找不到工具","id":"找不到工具","depth":3,"charIndex":909},{"text":"浏览器工具问题","id":"浏览器工具问题","depth":3,"charIndex":1041},{"text":"文件系统权限","id":"文件系统权限","depth":3,"charIndex":1215},{"text":"性能问题","id":"性能问题","depth":2,"charIndex":1454},{"text":"响应时间慢","id":"响应时间慢","depth":3,"charIndex":1462},{"text":"内存使用","id":"内存使用","depth":3,"charIndex":1791},{"text":"开发问题","id":"开发问题","depth":2,"charIndex":1962},{"text":"热重载不工作","id":"热重载不工作","depth":3,"charIndex":1970},{"text":"TypeScript 错误","id":"typescript-错误","depth":3,"charIndex":2143},{"text":"调试","id":"调试","depth":2,"charIndex":2322},{"text":"启用调试日志","id":"启用调试日志","depth":3,"charIndex":2328},{"text":"检查 Agent 状态","id":"检查-agent-状态","depth":3,"charIndex":2466},{"text":"网络问题","id":"网络问题","depth":3,"charIndex":2726},{"text":"获取帮助","id":"获取帮助","depth":2,"charIndex":2881},{"text":"日志文件","id":"日志文件","depth":3,"charIndex":2889},{"text":"常见错误代码","id":"常见错误代码","depth":3,"charIndex":2994},{"text":"社区支持","id":"社区支持","depth":3,"charIndex":3179},{"text":"下一步","id":"下一步","depth":2,"charIndex":3225}],"frontmatter":{"title":"故障排除","description":"Tarko Agent 常见问题和解决方案"},"version":""},{"title":"UI 集成","content":"#\n\nTarko 提供灵活的 UI 集成选项，帮助你使用现代 Web 技术为 Agent 构建用户界面。\n\n\n集成选项#\n\n\n1. Tarko Agent UI（推荐）#\n\n官方 Web UI 实现，可与任何 Tarko Agent 开箱即用：\n\nnpm install @tarko/agent-ui\n\n\n功能特性：\n\n * 实时 Agent 通信\n * 内置聊天界面\n * 工具执行可视化\n * 事件流监控\n * 响应式设计\n\n\n2. 自定义 Web UI#\n\n使用 Agent Protocol 构建自己的 Web 界面：\n\n\n\nconst client = new AgentClient({\n  endpoint: 'http://localhost:3000',\n});\n\n// 向 Agent 发送消息\nconst response = await client.sendMessage('你好，Agent！');\n\n\n\n3. 原生应用#\n\n使用 HTTP/WebSocket API 与桌面或移动应用集成。\n\n\n架构概览#\n\n┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐\n│   前端 UI       │◄──►│  Tarko Agent     │◄──►│  LLM Provider   │\n│                 │    │  Server          │    │                 │\n├─────────────────┤    ├──────────────────┤    ├─────────────────┤\n│ • 聊天界面      │    │ • Agent Protocol │    │ • OpenAI        │\n│ • 工具输出      │    │ • Event Stream   │    │ • Anthropic     │\n│ • 实时更新      │    │ • 工具执行       │    │ • Volcengine    │\n│                 │    │ • 上下文管理     │    │ • 其他          │\n└─────────────────┘    └──────────────────┘    └─────────────────┘\n\n\n\n使用 Tarko Agent UI 快速开始#\n\n为你的 Agent 获取 Web UI 的最快方式：\n\n\n1. 安装依赖#\n\nnpm install @tarko/agent-ui\n\n\n\n2. 基本设置#\n\n\nimport '@tarko/agent-ui/styles.css';\n\nfunction App() {\n  return (\n    <AgentUI\n      endpoint=\"http://localhost:3000\"\n      title=\"我的 Agent\"\n      theme=\"light\"\n    />\n  );\n}\n\nexport default App;\n\n\n\n3. 启动 Agent 服务器#\n\ntarko run --server\n\n\n你的 Web UI 将自动连接到 Agent！\n\n\n通信协议#\n\n\nHTTP API#\n\n用于基本 Agent 交互的 RESTful API：\n\n// 发送消息\nPOST /api/chat\n{\n  \"message\": \"你好，Agent！\",\n  \"sessionId\": \"session-123\"\n}\n\n// 获取会话历史\nGET /api/sessions/session-123/messages\n\n\n\nWebSocket#\n\n实时双向通信：\n\nconst ws = new WebSocket('ws://localhost:3000/ws');\n\nws.onmessage = (event) => {\n  const data = JSON.parse(event.data);\n  console.log('Agent 事件:', data);\n};\n\n\n\nServer-Sent Events (SSE)#\n\n用于实时更新的流式响应：\n\nconst eventSource = new EventSource('/api/stream/session-123');\n\neventSource.onmessage = (event) => {\n  const data = JSON.parse(event.data);\n  console.log('流更新:', data);\n};\n\n\n\nEvent Stream#\n\nTarko 使用标准化的事件流格式进行实时通信：\n\ninterface AgentEvent {\n  type: 'message' | 'tool_call' | 'tool_result' | 'thinking' | 'error';\n  timestamp: string;\n  sessionId: string;\n  data: any;\n}\n\n\n\n事件类型#\n\n事件类型          描述           数据\nmessage       Agent 响应消息   { content: string, role: 'assistant' }\ntool_call     工具执行开始       { name: string, args: object }\ntool_result   工具执行完成       { result: any, success: boolean }\nthinking      Agent 推理过程   { content: string }\nerror         发生错误         { message: string, code?: string }\n\n\n自定义 Web UI 开发#\n\n\nReact 集成#\n\n构建自定义 React 界面：\n\n\n\n\nconst CustomAgentUI = () => {\n  const [client] = useState(() => new AgentClient({\n    endpoint: 'http://localhost:3000'\n  }));\n  const [messages, setMessages] = useState([]);\n  const [input, setInput] = useState('');\n  const [loading, setLoading] = useState(false);\n\n  const sendMessage = async () => {\n    if (!input.trim()) return;\n    \n    setLoading(true);\n    const userMessage = { role: 'user', content: input };\n    setMessages(prev => [...prev, userMessage]);\n    setInput('');\n\n    try {\n      const response = await client.sendMessage(input);\n      const assistantMessage = { role: 'assistant', content: response.content };\n      setMessages(prev => [...prev, assistantMessage]);\n    } catch (error) {\n      console.error('发送消息时出错:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"agent-ui\">\n      <div className=\"messages\">\n        {messages.map((msg, idx) => (\n          <div key={idx} className={`message ${msg.role}`}>\n            {msg.content}\n          </div>\n        ))}\n      </div>\n      <div className=\"input-area\">\n        <input\n          value={input}\n          onChange={(e) => setInput(e.target.value)}\n          onKeyPress={(e) => e.key === 'Enter' && sendMessage()}\n          placeholder=\"输入你的消息...\"\n          disabled={loading}\n        />\n        <button onClick={sendMessage} disabled={loading}>\n          {loading ? '发送中...' : '发送'}\n        </button>\n      </div>\n    </div>\n  );\n};\n\n\n\nVue.js 集成#\n\n<template>\n  <div class=\"agent-ui\">\n    <div class=\"messages\">\n      <div\n        v-for=\"(message, index) in messages\"\n        :key=\"index\"\n        :class=\"`message ${message.role}`\"\n      >\n        {{ message.content }}\n      </div>\n    </div>\n    <div class=\"input-area\">\n      <input\n        v-model=\"input\"\n        @keyup.enter=\"sendMessage\"\n        placeholder=\"输入你的消息...\"\n        :disabled=\"loading\"\n      />\n      <button @click=\"sendMessage\" :disabled=\"loading\">\n        {{ loading ? '发送中...' : '发送' }}\n      </button>\n    </div>\n  </div>\n</template>\n\n<script>\n\n\nexport default {\n  data() {\n    return {\n      client: new AgentClient({ endpoint: 'http://localhost:3000' }),\n      messages: [],\n      input: '',\n      loading: false\n    };\n  },\n  methods: {\n    async sendMessage() {\n      if (!this.input.trim()) return;\n      \n      this.loading = true;\n      this.messages.push({ role: 'user', content: this.input });\n      const message = this.input;\n      this.input = '';\n\n      try {\n        const response = await this.client.sendMessage(message);\n        this.messages.push({ role: 'assistant', content: response.content });\n      } catch (error) {\n        console.error('错误:', error);\n      } finally {\n        this.loading = false;\n      }\n    }\n  }\n};\n</script>\n\n\n\n实时功能#\n\n\nWebSocket 连接#\n\n实现实时通信：\n\nclass AgentWebSocket {\n  private ws: WebSocket;\n  private eventHandlers: Map<string, Function[]> = new Map();\n\n  constructor(endpoint: string) {\n    this.ws = new WebSocket(endpoint.replace('http', 'ws') + '/ws');\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers() {\n    this.ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      const handlers = this.eventHandlers.get(data.type) || [];\n      handlers.forEach(handler => handler(data));\n    };\n\n    this.ws.onopen = () => {\n      console.log('WebSocket 已连接');\n    };\n\n    this.ws.onclose = () => {\n      console.log('WebSocket 已断开');\n      // 实现重连逻辑\n    };\n  }\n\n  on(eventType: string, handler: Function) {\n    if (!this.eventHandlers.has(eventType)) {\n      this.eventHandlers.set(eventType, []);\n    }\n    this.eventHandlers.get(eventType)!.push(handler);\n  }\n\n  sendMessage(message: string) {\n    this.ws.send(JSON.stringify({ type: 'message', content: message }));\n  }\n}\n\n// 使用示例\nconst agentWS = new AgentWebSocket('http://localhost:3000');\n\nagentWS.on('message', (data) => {\n  console.log('收到消息:', data.content);\n});\n\nagentWS.on('tool_call', (data) => {\n  console.log('工具调用:', data.name, data.args);\n});\n\nagentWS.on('tool_result', (data) => {\n  console.log('工具结果:', data.result);\n});\n\n\n\nServer-Sent Events#\n\n使用 SSE 的替代方法：\n\nclass AgentEventSource {\n  private eventSource: EventSource;\n  private sessionId: string;\n\n  constructor(endpoint: string, sessionId: string) {\n    this.sessionId = sessionId;\n    this.eventSource = new EventSource(`${endpoint}/api/stream/${sessionId}`);\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers() {\n    this.eventSource.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      this.handleEvent(data);\n    };\n\n    this.eventSource.onerror = (error) => {\n      console.error('SSE 错误:', error);\n    };\n  }\n\n  private handleEvent(data: any) {\n    switch (data.type) {\n      case 'message':\n        this.onMessage(data);\n        break;\n      case 'tool_call':\n        this.onToolCall(data);\n        break;\n      case 'tool_result':\n        this.onToolResult(data);\n        break;\n    }\n  }\n\n  onMessage(data: any) {\n    // 在子类中重写或传递回调\n  }\n\n  onToolCall(data: any) {\n    // 在子类中重写或传递回调\n  }\n\n  onToolResult(data: any) {\n    // 在子类中重写或传递回调\n  }\n\n  close() {\n    this.eventSource.close();\n  }\n}\n\n\n\nUI 组件#\n\n\n聊天界面#\n\n基本聊天组件结构：\n\ninterface ChatMessage {\n  id: string;\n  role: 'user' | 'assistant';\n  content: string;\n  timestamp: Date;\n  toolCalls?: ToolCall[];\n}\n\ninterface ToolCall {\n  id: string;\n  name: string;\n  args: object;\n  result?: any;\n  status: 'pending' | 'success' | 'error';\n}\n\n\n\n工具执行可视化#\n\n\n\ninterface ToolExecutionProps {\n  toolCall: {\n    name: string;\n    args: object;\n    result?: any;\n    status: 'pending' | 'success' | 'error';\n    startTime: Date;\n    endTime?: Date;\n  };\n}\n\nconst ToolExecution: React.FC<ToolExecutionProps> = ({ toolCall }) => {\n  const duration = toolCall.endTime \n    ? toolCall.endTime.getTime() - toolCall.startTime.getTime()\n    : null;\n\n  return (\n    <div className={`tool-execution ${toolCall.status}`}>\n      <div className=\"tool-header\">\n        <span className=\"tool-name\">{toolCall.name}</span>\n        <span className=\"tool-status\">{toolCall.status}</span>\n        {duration && (\n          <span className=\"tool-duration\">{duration}ms</span>\n        )}\n      </div>\n      \n      <details className=\"tool-args\">\n        <summary>参数</summary>\n        <pre>{JSON.stringify(toolCall.args, null, 2)}</pre>\n      </details>\n      \n      {toolCall.result && (\n        <details className=\"tool-result\">\n          <summary>结果</summary>\n          <pre>{JSON.stringify(toolCall.result, null, 2)}</pre>\n        </details>\n      )}\n    </div>\n  );\n};\n\n\n\n思考过程显示#\n\nconst ThinkingProcess: React.FC<{ thoughts: string[] }> = ({ thoughts }) => {\n  return (\n    <div className=\"thinking-process\">\n      <div className=\"thinking-header\">\n        <span>🤔 Agent 正在思考...</span>\n      </div>\n      <div className=\"thoughts\">\n        {thoughts.map((thought, idx) => (\n          <div key={idx} className=\"thought\">\n            {thought}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\n\n\n样式和主题#\n\n\nCSS 变量#\n\n:root {\n  --agent-primary: #007bff;\n  --agent-secondary: #6c757d;\n  --agent-success: #28a745;\n  --agent-danger: #dc3545;\n  --agent-warning: #ffc107;\n  --agent-info: #17a2b8;\n  \n  --agent-bg: #ffffff;\n  --agent-text: #333333;\n  --agent-border: #e9ecef;\n  \n  --agent-message-user-bg: #007bff;\n  --agent-message-user-text: #ffffff;\n  --agent-message-assistant-bg: #f8f9fa;\n  --agent-message-assistant-text: #333333;\n}\n\n[data-theme=\"dark\"] {\n  --agent-bg: #1a1a1a;\n  --agent-text: #ffffff;\n  --agent-border: #333333;\n  \n  --agent-message-assistant-bg: #2d2d2d;\n  --agent-message-assistant-text: #ffffff;\n}\n\n\n\n组件样式#\n\n.agent-ui {\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n  background: var(--agent-bg);\n  color: var(--agent-text);\n}\n\n.messages {\n  flex: 1;\n  overflow-y: auto;\n  padding: 1rem;\n}\n\n.message {\n  margin-bottom: 1rem;\n  padding: 0.75rem 1rem;\n  border-radius: 0.5rem;\n  max-width: 80%;\n}\n\n.message.user {\n  background: var(--agent-message-user-bg);\n  color: var(--agent-message-user-text);\n  margin-left: auto;\n}\n\n.message.assistant {\n  background: var(--agent-message-assistant-bg);\n  color: var(--agent-message-assistant-text);\n}\n\n.input-area {\n  display: flex;\n  padding: 1rem;\n  border-top: 1px solid var(--agent-border);\n}\n\n.input-area input {\n  flex: 1;\n  padding: 0.75rem;\n  border: 1px solid var(--agent-border);\n  border-radius: 0.25rem;\n  margin-right: 0.5rem;\n}\n\n.input-area button {\n  padding: 0.75rem 1.5rem;\n  background: var(--agent-primary);\n  color: white;\n  border: none;\n  border-radius: 0.25rem;\n  cursor: pointer;\n}\n\n.input-area button:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n\n\n认证与安全#\n\n\nAPI 密钥#\n\n安全的 API 密钥认证：\n\nconst client = new AgentClient({\n  endpoint: 'http://localhost:3000',\n  apiKey: process.env.TARKO_API_KEY,\n});\n\n\n\n会话管理#\n\n管理用户会话和上下文：\n\ninterface Session {\n  id: string;\n  userId?: string;\n  createdAt: Date;\n  lastActivity: Date;\n  context: AgentContext;\n}\n\n\n\n部署考虑#\n\n\nCORS 配置#\n\n对于 Web UI，在 Agent 服务器中配置 CORS：\n\nexport default defineConfig({\n  server: {\n    cors: {\n      origin: ['http://localhost:3000', 'https://myapp.com'],\n      credentials: true,\n    },\n  },\n});\n\n\n\n反向代理#\n\n在生产部署中使用反向代理：\n\nlocation /api/ {\n    proxy_pass http://localhost:3001/;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection 'upgrade';\n    proxy_set_header Host $host;\n    proxy_cache_bypass $http_upgrade;\n}\n\n\n\n环境配置#\n\n// config.ts\nexport const config = {\n  apiEndpoint: process.env.REACT_APP_API_ENDPOINT || 'http://localhost:3000',\n  wsEndpoint: process.env.REACT_APP_WS_ENDPOINT || 'ws://localhost:3000',\n  apiKey: process.env.REACT_APP_API_KEY,\n};\n\n\n\n构建和部署#\n\n# 生产构建\nnpm run build\n\n# 部署到静态托管\n# (Vercel, Netlify, AWS S3 等)\n\n\n\nDocker 部署#\n\n# Dockerfile\nFROM node:18-alpine\n\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY . .\nRUN npm run build\n\nFROM nginx:alpine\nCOPY --from=0 /app/build /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/nginx.conf\n\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n\n\n\n下一步#\n\n * Agent Protocol →\n * Event Stream →\n * 配置 →","routePath":"/zh/guide/basic/ui-integration","lang":"zh","toc":[{"text":"集成选项","id":"集成选项","depth":2,"charIndex":54},{"text":"1. **Tarko Agent UI**（推荐）","id":"1-tarko-agent-ui推荐","depth":3,"charIndex":-1},{"text":"2. **自定义 Web UI**","id":"2-自定义-web-ui","depth":3,"charIndex":-1},{"text":"3. **原生应用**","id":"3-原生应用","depth":3,"charIndex":-1},{"text":"架构概览","id":"架构概览","depth":2,"charIndex":463},{"text":"使用 Tarko Agent UI 快速开始","id":"使用-tarko-agent-ui-快速开始","depth":2,"charIndex":1051},{"text":"1. 安装依赖","id":"1-安装依赖","depth":3,"charIndex":1105},{"text":"2. 基本设置","id":"2-基本设置","depth":3,"charIndex":1146},{"text":"3. 启动 Agent 服务器","id":"3-启动-agent-服务器","depth":3,"charIndex":1356},{"text":"通信协议","id":"通信协议","depth":2,"charIndex":1421},{"text":"HTTP API","id":"http-api","depth":3,"charIndex":1429},{"text":"WebSocket","id":"websocket","depth":3,"charIndex":1604},{"text":"Server-Sent Events (SSE)","id":"server-sent-events-sse","depth":3,"charIndex":1785},{"text":"Event Stream","id":"event-stream","depth":2,"charIndex":2002},{"text":"事件类型","id":"事件类型","depth":3,"charIndex":2198},{"text":"自定义 Web UI 开发","id":"自定义-web-ui-开发","depth":2,"charIndex":2531},{"text":"React 集成","id":"react-集成","depth":3,"charIndex":2548},{"text":"Vue.js 集成","id":"vuejs-集成","depth":3,"charIndex":4040},{"text":"实时功能","id":"实时功能","depth":2,"charIndex":5336},{"text":"WebSocket 连接","id":"websocket-连接","depth":3,"charIndex":5344},{"text":"Server-Sent Events","id":"server-sent-events","depth":3,"charIndex":6650},{"text":"UI 组件","id":"ui-组件","depth":2,"charIndex":7716},{"text":"聊天界面","id":"聊天界面","depth":3,"charIndex":7725},{"text":"工具执行可视化","id":"工具执行可视化","depth":3,"charIndex":8009},{"text":"思考过程显示","id":"思考过程显示","depth":3,"charIndex":9111},{"text":"样式和主题","id":"样式和主题","depth":2,"charIndex":9546},{"text":"CSS 变量","id":"css-变量","depth":3,"charIndex":9555},{"text":"组件样式","id":"组件样式","depth":3,"charIndex":10169},{"text":"认证与安全","id":"认证与安全","depth":2,"charIndex":11201},{"text":"API 密钥","id":"api-密钥","depth":3,"charIndex":11210},{"text":"会话管理","id":"会话管理","depth":3,"charIndex":11348},{"text":"部署考虑","id":"部署考虑","depth":2,"charIndex":11492},{"text":"CORS 配置","id":"cors-配置","depth":3,"charIndex":11500},{"text":"反向代理","id":"反向代理","depth":3,"charIndex":11702},{"text":"环境配置","id":"环境配置","depth":3,"charIndex":11971},{"text":"构建和部署","id":"构建和部署","depth":3,"charIndex":12214},{"text":"Docker 部署","id":"docker-部署","depth":3,"charIndex":12287},{"text":"下一步","id":"下一步","depth":2,"charIndex":12578}],"frontmatter":{"title":"UI 集成","description":"为 Tarko Agent 构建 Web 界面"},"version":""},{"title":"CLI 部署","content":"#\n\nTarko Agent CLI 提供了一种简单的方式在各种环境中部署和运行基于 Tarko 的 Agent。使用 tarko run [agent]\n创建无头或有头的 Agent 运行时环境。\n\n\n安装#\n\n全局安装 Tarko CLI：\n\nnpm install -g @tarko/agent-cli\n\n\n或使用 npx：\n\nnpx @tarko/agent-cli run my-agent\n\n\n\n基础用法#\n\n\n运行 Agent#\n\n# 在当前目录运行 Agent\ntarko run\n\n# 运行特定 Agent\ntarko run ./my-agent\n\n# 使用自定义配置运行\ntarko run --config ./custom-config.json\n\n\n\n开发模式#\n\n# 在开发模式下运行，支持热重载\ntarko run --dev\n\n# 运行时启用调试日志\ntarko run --debug\n\n# 运行在特定端口\ntarko run --port 3001\n\n\n\n配置#\n\n\nCLI 配置文件#\n\n创建 tarko.config.js 文件：\n\nmodule.exports = {\n  name: 'MyAgent',\n  description: '一个有用的助手',\n  \n  // 运行时配置\n  runtime: {\n    port: 3000,\n    host: '0.0.0.0',\n    mode: 'production' // 或 'development'\n  },\n  \n  // 模型配置\n  model: {\n    provider: 'openai',\n    apiKey: process.env.OPENAI_API_KEY,\n    model: 'gpt-4'\n  },\n  \n  // 工具\n  tools: [\n    '@tarko/tools/file-system',\n    '@tarko/tools/browser',\n    './custom-tools/weather'\n  ],\n  \n  // UI 配置\n  ui: {\n    enabled: true,\n    theme: 'default',\n    title: 'My Agent'\n  }\n};\n\n\n\n环境变量#\n\n# 模型配置\nexport TARKO_MODEL_PROVIDER=openai\nexport TARKO_MODEL_API_KEY=your-api-key\nexport TARKO_MODEL_NAME=gpt-4\n\n# 运行时配置\nexport TARKO_PORT=3000\nexport TARKO_HOST=0.0.0.0\nexport TARKO_MODE=production\n\n# UI 配置\nexport TARKO_UI_ENABLED=true\nexport TARKO_UI_THEME=default\n\n\n\n部署模式#\n\n\n无头模式#\n\n运行无 UI，仅提供 API 访问：\n\ntarko run --headless\n\n\n配置：\n\nmodule.exports = {\n  runtime: {\n    mode: 'headless',\n    api: {\n      enabled: true,\n      cors: true,\n      rateLimit: {\n        windowMs: 15 * 60 * 1000, // 15 分钟\n        max: 100 // 每个 IP 在 windowMs 内限制 100 个请求\n      }\n    }\n  },\n  ui: {\n    enabled: false\n  }\n};\n\n\n\n有头模式#\n\n运行带 Web UI：\n\ntarko run --ui\n\n\n配置：\n\nmodule.exports = {\n  ui: {\n    enabled: true,\n    title: 'My Agent',\n    theme: 'default',\n    customization: {\n      logo: './assets/logo.png',\n      primaryColor: '#007bff',\n      layout: 'sidebar' // 或 'topbar'\n    }\n  }\n};\n\n\n\n生产部署#\n\n\nDocker#\n\n创建 Dockerfile：\n\nFROM node:18-alpine\n\nWORKDIR /app\n\n# 复制包文件\nCOPY package*.json ./\nRUN npm ci --only=production\n\n# 复制 Agent 代码\nCOPY . .\n\n# 安装 Tarko CLI\nRUN npm install -g @tarko/agent-cli\n\nEXPOSE 3000\n\nCMD [\"tarko\", \"run\", \"--port\", \"3000\", \"--host\", \"0.0.0.0\"]\n\n\n构建和运行：\n\ndocker build -t my-agent .\ndocker run -p 3000:3000 -e OPENAI_API_KEY=your-key my-agent\n\n\n\nDocker Compose#\n\nversion: '3.8'\n\nservices:\n  agent:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - TARKO_MODEL_PROVIDER=openai\n      - TARKO_MODEL_API_KEY=${OPENAI_API_KEY}\n      - TARKO_MODEL_NAME=gpt-4\n      - TARKO_MODE=production\n    volumes:\n      - ./data:/app/data\n    restart: unless-stopped\n\n  redis:\n    image: redis:alpine\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis_data:/data\n    restart: unless-stopped\n\nvolumes:\n  redis_data:\n\n\n\n进程管理器 (PM2)#\n\n// ecosystem.config.js\nmodule.exports = {\n  apps: [{\n    name: 'my-agent',\n    script: 'tarko',\n    args: 'run --port 3000',\n    instances: 1,\n    autorestart: true,\n    watch: false,\n    max_memory_restart: '1G',\n    env: {\n      NODE_ENV: 'production',\n      TARKO_MODEL_PROVIDER: 'openai',\n      TARKO_MODEL_API_KEY: process.env.OPENAI_API_KEY\n    }\n  }]\n};\n\n\n部署：\n\nnpm install -g pm2\npm2 start ecosystem.config.js\npm2 save\npm2 startup\n\n\n\n监控和日志#\n\n\n健康检查#\n\n# 检查 Agent 状态\ncurl http://localhost:3000/health\n\n# 检查详细状态\ncurl http://localhost:3000/status\n\n\n\n日志配置#\n\nmodule.exports = {\n  logging: {\n    level: 'info', // debug, info, warn, error\n    format: 'json', // json, text\n    output: {\n      console: true,\n      file: {\n        enabled: true,\n        path: './logs/agent.log',\n        maxSize: '10m',\n        maxFiles: 5\n      }\n    }\n  }\n};\n\n\n\n指标#\n\n启用指标收集：\n\nmodule.exports = {\n  metrics: {\n    enabled: true,\n    endpoint: '/metrics',\n    collectors: {\n      requests: true,\n      responses: true,\n      toolCalls: true,\n      errors: true\n    }\n  }\n};\n\n\n\n负载均衡#\n\n\nNginx 配置#\n\nupstream tarko_agents {\n    server localhost:3000;\n    server localhost:3001;\n    server localhost:3002;\n}\n\nserver {\n    listen 80;\n    server_name my-agent.example.com;\n    \n    location / {\n        proxy_pass http://tarko_agents;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection 'upgrade';\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_cache_bypass $http_upgrade;\n    }\n}\n\n\n\n故障排除#\n\n\n常见问题#\n\n端口已被使用：\n\n# 查找使用端口的进程\nlsof -i :3000\n\n# 终止进程\nkill -9 <PID>\n\n# 或使用不同端口\ntarko run --port 3001\n\n\n权限错误：\n\n# 使用 sudo 运行（不推荐）\nsudo tarko run\n\n# 或更改为非特权端口\ntarko run --port 8080\n\n\n内存问题：\n\n# 增加 Node.js 内存限制\nNODE_OPTIONS=\"--max-old-space-size=4096\" tarko run\n\n\n\n调试模式#\n\n# 启用调试日志\nDEBUG=tarko:* tarko run --debug\n\n# 启用 Node.js 检查器\ntarko run --inspect\n\n# 启用详细输出\ntarko run --verbose\n","routePath":"/zh/guide/deployment/cli","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":101},{"text":"基础用法","id":"基础用法","depth":2,"charIndex":204},{"text":"运行 Agent","id":"运行-agent","depth":3,"charIndex":212},{"text":"开发模式","id":"开发模式","depth":3,"charIndex":340},{"text":"配置","id":"配置","depth":2,"charIndex":447},{"text":"CLI 配置文件","id":"cli-配置文件","depth":3,"charIndex":453},{"text":"环境变量","id":"环境变量","depth":3,"charIndex":986},{"text":"部署模式","id":"部署模式","depth":2,"charIndex":1263},{"text":"无头模式","id":"无头模式","depth":3,"charIndex":1271},{"text":"有头模式","id":"有头模式","depth":3,"charIndex":1597},{"text":"生产部署","id":"生产部署","depth":2,"charIndex":1869},{"text":"Docker","id":"docker","depth":3,"charIndex":1877},{"text":"Docker Compose","id":"docker-compose","depth":3,"charIndex":2246},{"text":"进程管理器 (PM2)","id":"进程管理器-pm2","depth":3,"charIndex":2726},{"text":"监控和日志","id":"监控和日志","depth":2,"charIndex":3181},{"text":"健康检查","id":"健康检查","depth":3,"charIndex":3190},{"text":"日志配置","id":"日志配置","depth":3,"charIndex":3292},{"text":"指标","id":"指标","depth":3,"charIndex":3586},{"text":"负载均衡","id":"负载均衡","depth":2,"charIndex":3798},{"text":"Nginx 配置","id":"nginx-配置","depth":3,"charIndex":3806},{"text":"故障排除","id":"故障排除","depth":2,"charIndex":4436},{"text":"常见问题","id":"常见问题","depth":3,"charIndex":4444},{"text":"调试模式","id":"调试模式","depth":3,"charIndex":4699}],"frontmatter":{"title":"CLI 部署","description":"使用 CLI 部署 Tarko Agent"},"version":""},{"title":"服务器","content":"#\n\n使用 Tarko Agent Server 构建生产就绪的 Agent 服务器。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的服务器文档，包括：\n\n * 服务器安装和配置\n * Session 管理 API\n * Query 执行 API\n * WebSocket 通信\n * 存储提供商\n * 部署指南\n\n目前请参考 英文版服务器文档 了解详细信息。","routePath":"/zh/guide/deployment/server","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":45}],"frontmatter":{"title":"服务器","description":"使用 Tarko Agent Server 构建生产就绪的 Agent 服务器"},"version":""},{"title":"架构设计","content":"#\n\n了解 Tarko 的三层架构设计。\n\n\n即将推出#\n\n此部分正在开发中，敬请期待详细的架构文档，包括：\n\n * 三层架构详解\n * 工程层组件\n * 应用层实现\n * 内核层核心能力\n * 设计原则\n\n目前请参考 英文版架构文档 了解详细信息。","routePath":"/zh/guide/get-started/architecture","lang":"zh","toc":[{"text":"即将推出","id":"即将推出","depth":2,"charIndex":22}],"frontmatter":{"title":"架构设计","description":"了解 Tarko 的三层架构设计"},"version":""},{"title":"介绍","content":"#\n\nTarko (Tool-augmented Agent Runtime Kernel, Open-source)，发音是 /ˈtɑːrkoʊ/，是一个以\n\"Tool Call\" 和 \"事件流\" 驱动的 Agent 运行时框架，内置了强大的 Context Engineering 能力。\n\n\n什么是 Tarko？#\n\nTarko 提供以下核心能力：\n\n * Context Engineering: 构建支持长程运行的 Agent 核心能力\n * Tool Call Engine: 支持多种 LLM Provider 的统一工具调用接口\n * Event Stream Processing: 原生流式处理和 Agent Protocol 支持\n * Agent Hooks: 强大的扩展能力\n * Agent Protocol: Agent 生命周期的标准格式定义\n\n\n核心特性#\n\n\n🔧 Tool Call Engine#\n\n支持多种 Tool Call 引擎，包括原生 Function Call、自定义解析器，以及不支持原生 Function Tool 的模型。\n\n\n🌊 Event Stream#\n\n内置事件流处理，支持原生流式传输和标准化的 Agent Protocol。\n\n\n🧠 Context Engineering#\n\n先进的上下文管理，支持长程运行的 Agent 操作和自动上下文优化。\n\n\n🔌 Agent Hooks#\n\n可扩展的钩子系统，允许在执行的每个阶段自定义 Agent 行为。\n\n\n架构概览#\n\nTarko 采用三层架构设计：\n\n 1. 工程层: CLI、Server 和 UI 组件\n 2. 应用层: 基于 Tarko 的 Agent 实现\n 3. 内核层: 包含 Context Engineering 和 Agent Protocol 的核心运行时\n\n\n谁在使用 Tarko？#\n\nTarko 驱动了多个生产系统：\n\n * UI-TARS-2: 先进的 UI 自动化\n * UI-TARS-desktop: 桌面自动化\n * Agent TARS: 通用多模态 Agent\n\n\n下一步#\n\n * 快速开始 - 创建你的第一个 Tarko Agent\n * 架构设计 - 了解 Tarko 的设计原理\n * 示例 - 探索实用示例","routePath":"/zh/guide/get-started/introduction","lang":"zh","toc":[{"text":"什么是 Tarko？","id":"什么是-tarko","depth":2,"charIndex":148},{"text":"核心特性","id":"核心特性","depth":2,"charIndex":389},{"text":"🔧 Tool Call Engine","id":"-tool-call-engine","depth":3,"charIndex":397},{"text":"🌊 Event Stream","id":"-event-stream","depth":3,"charIndex":492},{"text":"🧠 Context Engineering","id":"-context-engineering","depth":3,"charIndex":550},{"text":"🔌 Agent Hooks","id":"-agent-hooks","depth":3,"charIndex":612},{"text":"架构概览","id":"架构概览","depth":2,"charIndex":664},{"text":"谁在使用 Tarko？","id":"谁在使用-tarko","depth":2,"charIndex":803},{"text":"下一步","id":"下一步","depth":2,"charIndex":915}],"frontmatter":{"title":"介绍","description":"了解 Tarko，一个工具增强的 Agent 运行时内核"},"version":""},{"title":"快速开始","content":"#\n\n几分钟内开始使用 Tarko。\n\n\n前置要求#\n\n * Node.js 18+\n * npm 或 pnpm\n\n\n安装#\n\n\n创建新的 Agent（开发中）#\n\n🚧 开发中：使用 Tarko CLI 的最快方式即将推出：\n\nnpm create tarko  # 即将推出\n\n\n\n安装 Tarko 包#\n\n目前请手动安装核心包：\n\nnpm install @tarko/agent\n\n\n\n基本使用#\n\n\n1. 定义你的 Agent#\n\n基于真实示例创建 agent.ts 文件：\n\n// 来自 multimodal/tarko/agent/examples/tool-calls/basic.ts\n\n\nconst locationTool = new Tool({\n  id: 'getCurrentLocation',\n  description: \"获取用户当前位置\",\n  parameters: z.object({}),\n  function: async () => {\n    return { location: 'Boston' };\n  },\n});\n\nconst weatherTool = new Tool({\n  id: 'getWeather',\n  description: '获取指定位置的天气信息',\n  parameters: z.object({\n    location: z.string().describe('位置名称，如城市名'),\n  }),\n  function: async (input) => {\n    const { location } = input;\n    return {\n      location,\n      temperature: '70°F (21°C)',\n      condition: 'Sunny',\n      precipitation: '10%',\n      humidity: '45%',\n      wind: '5 mph',\n    };\n  },\n});\n\nconst agent = new Agent({\n  model: {\n    provider: 'volcengine',\n    id: 'ep-20250510145437-5sxhs',\n    apiKey: process.env.ARK_API_KEY,\n  },\n  tools: [locationTool, weatherTool],\n  logLevel: LogLevel.DEBUG,\n});\n\nexport default agent;\n\n\n\n2. 运行你的 Agent#\n\n直接运行你的 Agent：\n\n// 运行 Agent\nconst response = await agent.run(\"今天天气怎么样？\");\nconsole.log(response);\n\n\n\n3. 流式示例#\n\n对于流式响应：\n\n// 来自 multimodal/tarko/agent/examples/streaming/tool-calls.ts\nconst response = await agent.run({\n  input: \"今天天气怎么样？\",\n  stream: true,\n});\n\nfor await (const chunk of response) {\n  console.log(chunk);\n}\n\n\n\n环境变量#\n\n创建包含 API 密钥的 .env 文件：\n\n# .env 文件\nARK_API_KEY=your-volcengine-api-key\nOPENAI_API_KEY=your-openai-api-key\nANTHROPIC_API_KEY=your-anthropic-api-key\n\n\n\n真实示例#\n\n探索仓库中的工作示例：\n\n * multimodal/tarko/agent/examples/tool-calls/basic.ts - 基础工具调用\n * multimodal/tarko/agent/examples/streaming/tool-calls.ts - 流式工具调用\n * multimodal/tarko/agent/examples/model-providers/ - 不同模型提供商\n\n\n下一步#\n\n * SDK 参考 - 完整 API 参考\n * 架构设计 - 了解 Tarko 的设计\n * 工具 - 创建自定义工具\n * 示例 - 探索实际案例\n\n\n测试示例#\n\n测试示例是否工作：\n\n# 克隆仓库\ngit clone https://github.com/bytedance/UI-TARS-desktop.git\ncd UI-TARS-desktop/multimodal/tarko/agent\n\n# 安装依赖\nnpm install\n\n# 运行基础工具调用示例\nnpx tsx examples/tool-calls/basic.ts\n\n# 运行流式示例\nnpx tsx examples/streaming/tool-calls.ts\n","routePath":"/zh/guide/get-started/quick-start","lang":"zh","toc":[{"text":"前置要求","id":"前置要求","depth":2,"charIndex":20},{"text":"安装","id":"安装","depth":2,"charIndex":58},{"text":"创建新的 Agent（开发中）","id":"创建新的-agent开发中","depth":3,"charIndex":64},{"text":"安装 Tarko 包","id":"安装-tarko-包","depth":3,"charIndex":142},{"text":"基本使用","id":"基本使用","depth":2,"charIndex":196},{"text":"1. 定义你的 Agent","id":"1-定义你的-agent","depth":3,"charIndex":204},{"text":"2. 运行你的 Agent","id":"2-运行你的-agent","depth":3,"charIndex":1128},{"text":"3. 流式示例","id":"3-流式示例","depth":3,"charIndex":1243},{"text":"环境变量","id":"环境变量","depth":2,"charIndex":1466},{"text":"真实示例","id":"真实示例","depth":2,"charIndex":1621},{"text":"下一步","id":"下一步","depth":2,"charIndex":1837},{"text":"测试示例","id":"测试示例","depth":2,"charIndex":1921}],"frontmatter":{"title":"快速开始","description":"几分钟内开始使用 Tarko"},"version":""},{"title":"SDK","content":"#\n\nTarko 可以作为 SDK 使用，直接将 Agent 能力集成到你的应用中。这种方式让你完全控制 Agent 的生命周期，并允许深度定制。\n\n\n安装#\n\n安装核心 Tarko 包：\n\nnpm install @tarko/agent @tarko/tools\n\n\n安装特定工具：\n\nnpm install @tarko/tools-browser @tarko/tools-filesystem\n\n\n\n基础用法#\n\n\n创建 Agent#\n\n\n\n// 创建自定义工具\nconst weatherTool = new Tool({\n  id: 'getWeather',\n  description: '获取指定位置的天气信息',\n  parameters: z.object({\n    location: z.string().describe('位置名称，如城市名'),\n  }),\n  function: async (input) => {\n    const { location } = input;\n    return {\n      location,\n      temperature: '70°F (21°C)',\n      condition: 'Sunny',\n    };\n  },\n});\n\nconst agent = new Agent({\n  name: 'MyAgent',\n  \n  model: {\n    provider: 'openai',\n    id: 'gpt-4',\n    apiKey: process.env.OPENAI_API_KEY,\n  },\n  \n  instructions: `你是一个有用的助手，可以获取天气信息。`,\n  \n  tools: [weatherTool]\n});\n\n\n\n运行 Agent#\n\n// 简单运行\nconst response = await agent.run('你好，可以帮助我吗？');\nconsole.log(response);\n\n// 使用配置选项运行\nconst response2 = await agent.run({\n  input: '今天天气怎么样？',\n  sessionId: 'my-session'\n});\n\n\n\n流式响应#\n\nconst stream = await agent.run({\n  input: '写一个关于 AI 的长故事',\n  stream: true\n});\n\nfor await (const chunk of stream) {\n  if (chunk.type === 'assistant_message') {\n    process.stdout.write(chunk.content);\n  } else if (chunk.type === 'tool_call') {\n    console.log('调用工具:', chunk.toolCall.function.name);\n  }\n}\n\n\n\n高级用法#\n\n\n自定义工具#\n\n创建特定领域的工具：\n\n\n\n// 创建数据库查询工具\nconst databaseTool = new Tool({\n  id: 'query_database',\n  description: '查询应用数据库',\n  parameters: z.object({\n    query: z.string().describe('要执行的 SQL 查询'),\n    limit: z.number().optional().describe('结果限制数量')\n  }),\n  function: async (params) => {\n    const { query, limit = 10 } = params;\n    // 你的数据库逻辑\n    const results = await myDatabase.query(query, { limit });\n    return { results, count: results.length };\n  },\n});\n\nconst agent = new Agent({\n  model: {\n    provider: 'openai',\n    id: 'gpt-4',\n    apiKey: process.env.OPENAI_API_KEY,\n  },\n  tools: [databaseTool]\n});\n\n\n\n事件处理#\n\n// 获取事件流处理器\nconst eventStream = agent.getEventStream();\n\n// 监听工具调用事件\neventStream.on('tool_call', (event) => {\n  console.log(`调用工具: ${event.toolCall.function.name}`);\n  // 记录到分析系统、更新 UI 等\n});\n\n// 监听错误事件\neventStream.on('error', (event) => {\n  console.error('Agent 错误:', event.error);\n  // 处理错误、通知用户等\n});\n\n// 监听 Agent 运行状态\neventStream.on('agent_run_start', (event) => {\n  console.log('Agent 开始运行:', event.sessionId);\n});\n\neventStream.on('agent_run_end', (event) => {\n  console.log('Agent 运行结束:', event.iterations, '次迭代');\n});\n\n\n\n上下文管理#\n\nconst agent = new Agent({\n  model: {\n    provider: 'openai',\n    id: 'gpt-4',\n    apiKey: process.env.OPENAI_API_KEY,\n  },\n  context: {\n    maxImagesCount: 5,  // 支持的最大图片数量\n  }\n});\n\n// 生成对话摘要\nconst summary = await agent.generateSummary({\n  messages: conversationHistory,\n});\nconsole.log('对话摘要:', summary.summary);\n\n\n\nAgent Hooks#\n\nTarko 提供多种钩子来自定义 Agent 行为。通过继承 Agent 类并重写钩子方法：\n\n\n\nclass CustomAgent extends Agent {\n  async onBeforeToolCall(id: string, toolCall: any, args: any) {\n    // 验证工具调用\n    if (toolCall.name === 'dangerous_operation') {\n      throw new Error('不允许此操作');\n    }\n    return args;\n  }\n  \n  async onAfterToolCall(id: string, toolCall: any, result: any) {\n    // 记录结果\n    await this.logToolResult(toolCall, result);\n    return result;\n  }\n  \n  async onToolCallError(id: string, toolCall: any, error: any) {\n    // 自定义错误处理\n    console.error('工具调用错误:', toolCall.name, error);\n    return { error: '工具执行失败，请重试' };\n  }\n  \n  private async logToolResult(toolCall: any, result: any) {\n    console.log(`工具 ${toolCall.name} 执行完成:`, result);\n  }\n}\n\nconst agent = new CustomAgent({\n  model: {\n    provider: 'openai',\n    id: 'gpt-4',\n    apiKey: process.env.OPENAI_API_KEY,\n  },\n  tools: [weatherTool]\n});\n\n\n\n集成模式#\n\n\nExpress.js 集成#\n\n\n\n\nconst app = express();\nconst agent = new Agent(config);\n\napp.use(express.json());\n\n// 聊天端点\napp.post('/chat', async (req, res) => {\n  try {\n    const { message, conversationId } = req.body;\n    \n    const conversation = conversationId \n      ? agent.getConversation(conversationId)\n      : agent.createConversation();\n    \n    const response = await conversation.chat(message);\n    \n    res.json({\n      response,\n      conversationId: conversation.id\n    });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// 流式端点\napp.get('/chat/stream', async (req, res) => {\n  const { message } = req.query;\n  \n  res.writeHead(200, {\n    'Content-Type': 'text/event-stream',\n    'Cache-Control': 'no-cache',\n    'Connection': 'keep-alive'\n  });\n  \n  const stream = agent.chatStream(message as string);\n  \n  for await (const chunk of stream) {\n    res.write(`data: ${JSON.stringify(chunk)}\\n\\n`);\n  }\n  \n  res.end();\n});\n\napp.listen(3000);\n\n\n\nReact 集成#\n\n\n\n\nfunction useAgent(config: AgentConfig) {\n  const [agent, setAgent] = useState<Agent | null>(null);\n  const [loading, setLoading] = useState(false);\n  \n  useEffect(() => {\n    const agentInstance = new Agent(config);\n    setAgent(agentInstance);\n    \n    return () => {\n      agentInstance.dispose();\n    };\n  }, []);\n  \n  const chat = async (message: string) => {\n    if (!agent) return;\n    \n    setLoading(true);\n    try {\n      const response = await agent.chat(message);\n      return response;\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  return { agent, chat, loading };\n}\n\nfunction ChatComponent() {\n  const { chat, loading } = useAgent({\n    model: { provider: 'openai', apiKey: 'your-key', model: 'gpt-4' },\n    tools: []\n  });\n  \n  const [message, setMessage] = useState('');\n  const [response, setResponse] = useState('');\n  \n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    const result = await chat(message);\n    setResponse(result || '');\n    setMessage('');\n  };\n  \n  return (\n    <div>\n      <form onSubmit={handleSubmit}>\n        <input\n          value={message}\n          onChange={(e) => setMessage(e.target.value)}\n          disabled={loading}\n        />\n        <button type=\"submit\" disabled={loading}>\n          {loading ? '思考中...' : '发送'}\n        </button>\n      </form>\n      {response && <div>{response}</div>}\n    </div>\n  );\n}\n\n\n\n最佳实践#\n\n\n错误处理#\n\ntry {\n  const response = await agent.chat(message);\n  return response;\n} catch (error) {\n  if (error instanceof ToolExecutionError) {\n    // 处理工具特定错误\n    console.error('工具错误:', error.toolName, error.message);\n  } else if (error instanceof ModelProviderError) {\n    // 处理模型提供商错误\n    console.error('模型错误:', error.provider, error.message);\n  } else {\n    // 处理一般错误\n    console.error('意外错误:', error.message);\n  }\n  \n  throw error;\n}\n\n\n\n资源管理#\n\nclass AgentManager {\n  private agents = new Map<string, Agent>();\n  \n  getAgent(userId: string): Agent {\n    if (!this.agents.has(userId)) {\n      const agent = new Agent(this.getConfigForUser(userId));\n      this.agents.set(userId, agent);\n      \n      // 非活跃后清理\n      setTimeout(() => {\n        this.agents.delete(userId);\n        agent.dispose();\n      }, 30 * 60 * 1000); // 30 分钟\n    }\n    \n    return this.agents.get(userId)!;\n  }\n  \n  dispose() {\n    for (const agent of this.agents.values()) {\n      agent.dispose();\n    }\n    this.agents.clear();\n  }\n}\n","routePath":"/zh/guide/get-started/sdk","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":75},{"text":"基础用法","id":"基础用法","depth":2,"charIndex":204},{"text":"创建 Agent","id":"创建-agent","depth":3,"charIndex":212},{"text":"运行 Agent","id":"运行-agent","depth":3,"charIndex":785},{"text":"流式响应","id":"流式响应","depth":3,"charIndex":978},{"text":"高级用法","id":"高级用法","depth":2,"charIndex":1293},{"text":"自定义工具","id":"自定义工具","depth":3,"charIndex":1301},{"text":"事件处理","id":"事件处理","depth":3,"charIndex":1910},{"text":"上下文管理","id":"上下文管理","depth":3,"charIndex":2443},{"text":"Agent Hooks","id":"agent-hooks","depth":3,"charIndex":2768},{"text":"集成模式","id":"集成模式","depth":2,"charIndex":3666},{"text":"Express.js 集成","id":"expressjs-集成","depth":3,"charIndex":3674},{"text":"React 集成","id":"react-集成","depth":3,"charIndex":4654},{"text":"最佳实践","id":"最佳实践","depth":2,"charIndex":6071},{"text":"错误处理","id":"错误处理","depth":3,"charIndex":6079},{"text":"资源管理","id":"资源管理","depth":3,"charIndex":6518}],"frontmatter":{"title":"SDK","description":"在应用中使用 Tarko SDK"},"version":""}]